"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * ShipEngine API
 * ShipEngine\'s easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.  Each of ShipEngine\'s features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.  ## Getting Started If you\'re new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.  Here are some step-by-step **tutorials** to get you started:    - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)   - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)   - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)   - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)   ## Shipping Labels for Every Major Carrier ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).   ## Real-Time Package Tracking With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.   ## Compare Shipping Costs Across Carriers Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don\'t know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.   ## Worldwide Address Validation ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others.
 *
 * The version of the OpenAPI document: 1.1.202307171907
 * Contact: sales@shipengine.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaxableEntityType = exports.StatusCode = exports.SortDir = exports.SmartPostHub = exports.ShipmentsSortBy = exports.ShipmentStatus = exports.Redirect = exports.ReasonCode = exports.RateType = exports.RateResponseStatus = exports.PackageContents = exports.OriginType = exports.OrderSourceName = exports.NonDelivery = exports.ManifestRequestStatus = exports.ListServicePointsResponseBodyServicePointsInnerTypeEnum = exports.ListServicePointsResponseBodyServicePointsInnerFeaturesEnum = exports.LabelStatus = exports.LabelLayout = exports.LabelFormat = exports.LabelDownloadType = exports.LabelChargeEvent = exports.InsuranceProvider = exports.IdentifierType = exports.GetServicePointByIdResponseBodyServicePointTypeEnum = exports.GetServicePointByIdResponseBodyServicePointFeaturesEnum = exports.GetAccountSettingsImagesResponseBodyImageContentTypeEnum = exports.FedexPickupType = exports.ErrorType = exports.ErrorSource = exports.ErrorCode = exports.DisplayScheme = exports.DimensionUnit = exports.DeliveryConfirmation = exports.DefaultLabelLayout = exports.CreateAccountSettingsImageRequestBodyImageContentTypeEnum = exports.CollectOnDeliveryPaymentType = exports.CarrierNameWithSettings = exports.CarrierName = exports.BillToParty = exports.BatchesSortBy = exports.BatchStatus = exports.AncillaryServiceEndorsement = exports.AllowedIncoterms = exports.AddressValidationStatus = exports.AddressValidationMessageType = exports.AddressValidationDetailCode = exports.AddressValidationCode = exports.AddressResidentialIndicator = exports.AccountSettingsImagesImageContentTypeEnum = void 0;
exports.PackageTypesApiFp = exports.PackageTypesApiAxiosParamCreator = exports.PackagePickupsApi = exports.PackagePickupsApiFactory = exports.PackagePickupsApiFp = exports.PackagePickupsApiAxiosParamCreator = exports.ManifestsApi = exports.ManifestsApiFactory = exports.ManifestsApiFp = exports.ManifestsApiAxiosParamCreator = exports.ListLabelsSortByEnum = exports.LabelsApi = exports.LabelsApiFactory = exports.LabelsApiFp = exports.LabelsApiAxiosParamCreator = exports.InsuranceApi = exports.InsuranceApiFactory = exports.InsuranceApiFp = exports.InsuranceApiAxiosParamCreator = exports.DownloadsApi = exports.DownloadsApiFactory = exports.DownloadsApiFp = exports.DownloadsApiAxiosParamCreator = exports.CarriersApi = exports.CarriersApiFactory = exports.CarriersApiFp = exports.CarriersApiAxiosParamCreator = exports.CarrierAccountsApi = exports.CarrierAccountsApiFactory = exports.CarrierAccountsApiFp = exports.CarrierAccountsApiAxiosParamCreator = exports.BatchesApi = exports.BatchesApiFactory = exports.BatchesApiFp = exports.BatchesApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.AccountApi = exports.AccountApiFactory = exports.AccountApiFp = exports.AccountApiAxiosParamCreator = exports.WeightUnit = exports.WebhookEvent = exports.ValidationStatus = exports.ValidateAddress = exports.UpsPickupType = exports.UpdateAccountSettingsImageRequestBodyImageContentTypeEnum = exports.TrackingStatus = void 0;
exports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiAxiosParamCreator = exports.WarehousesApi = exports.WarehousesApiFactory = exports.WarehousesApiFp = exports.WarehousesApiAxiosParamCreator = exports.TrackingApi = exports.TrackingApiFactory = exports.TrackingApiFp = exports.TrackingApiAxiosParamCreator = exports.TokensApi = exports.TokensApiFactory = exports.TokensApiFp = exports.TokensApiAxiosParamCreator = exports.TagsApi = exports.TagsApiFactory = exports.TagsApiFp = exports.TagsApiAxiosParamCreator = exports.ShipmentsApi = exports.ShipmentsApiFactory = exports.ShipmentsApiFp = exports.ShipmentsApiAxiosParamCreator = exports.ServicePointsApi = exports.ServicePointsApiFactory = exports.ServicePointsApiFp = exports.ServicePointsApiAxiosParamCreator = exports.RatesApi = exports.RatesApiFactory = exports.RatesApiFp = exports.RatesApiAxiosParamCreator = exports.PackageTypesApi = exports.PackageTypesApiFactory = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.AccountSettingsImagesImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
/**
 * Indicates whether an address is residential.
 * @export
 * @enum {string}
 */
exports.AddressResidentialIndicator = {
    Unknown: 'unknown',
    Yes: 'yes',
    No: 'no'
};
/**
 * The error codes that can be returned by the address validation API
 * @export
 * @enum {string}
 */
exports.AddressValidationCode = {
    A1000: 'a1000',
    A1001: 'a1001',
    A1002: 'a1002',
    A1003: 'a1003',
    A1004: 'a1004',
    A1005: 'a1005',
    A1006: 'a1006',
    A1007: 'a1007',
    A1008: 'a1008',
    R1000: 'r1000',
    R1001: 'r1001',
    R1002: 'r1002',
    R1003: 'r1003'
};
/**
 * The detailed error codes that can be returned by the address validation API
 * @export
 * @enum {string}
 */
exports.AddressValidationDetailCode = {
    UnsupportedCountry: 'unsupported_country',
    NonSupportedCountry: 'non_supported_country',
    MinimumPostalCodeVerificationFailed: 'minimum_postal_code_verification_failed',
    StreetDoesNotMatchUniqueStreetName: 'street_does_not_match_unique_street_name',
    MultipleDirectionals: 'multiple_directionals',
    MultipleMatches: 'multiple_matches',
    SuiteNotValid: 'suite_not_valid',
    SuiteMissing: 'suite_missing',
    IncompatiblePairedLabels: 'incompatible_paired_labels',
    InvalidHouseNumber: 'invalid_house_number',
    MissingHouseNumber: 'missing_house_number',
    InvalidBoxNumber: 'invalid_box_number',
    InvalidChargeEvent: 'invalid_charge_event',
    MissingBoxNumber: 'missing_box_number',
    MissingCmraOrPrivateMailBoxNumber: 'missing_cmra_or_private_mail_box_number',
    SuiteHasNoSecondaries: 'suite_has_no_secondaries',
    PostalCodeChangedOrAdded: 'postal_code_changed_or_added',
    StateProvinceChangedOrAdded: 'state_province_changed_or_added',
    CityLocalityChangedOrAdded: 'city_locality_changed_or_added',
    UrbanizationChanged: 'urbanization_changed',
    StreetNameSpellingChangedOrAdded: 'street_name_spelling_changed_or_added',
    StreetNameTypeChangedOrAdded: 'street_name_type_changed_or_added',
    StreetDirectionChangedOrAdded: 'street_direction_changed_or_added',
    SuiteTypeChangedOrAdded: 'suite_type_changed_or_added',
    SuiteUnitNumberChangedOrAdded: 'suite_unit_number_changed_or_added',
    DoubleDependentLocalityChangedOrAdded: 'double_dependent_locality_changed_or_added',
    SubadministrativeAreaChangedOrAdded: 'subadministrative_area_changed_or_added',
    SubnationalAreaChangedOrAdded: 'subnational_area_changed_or_added',
    PoBoxChangedOrAdded: 'po_box_changed_or_added',
    PremiseTypeChangedOrAdded: 'premise_type_changed_or_added',
    HouseNumberChanged: 'house_number_changed',
    OrganizationChangedOrAdded: 'organization_changed_or_added',
    PartiallyVerifiedToStateLevel: 'partially_verified_to_state_level',
    PartiallyVerifiedToCityLevel: 'partially_verified_to_city_level',
    PartiallyVerifiedToStreetLevel: 'partially_verified_to_street_level',
    PartiallyVerifiedToPremiseLevel: 'partially_verified_to_premise_level',
    VerifiedToStateLevel: 'verified_to_state_level',
    VerifiedToCityLevel: 'verified_to_city_level',
    VerifiedToStreetLevel: 'verified_to_street_level',
    VerifiedToPremiseLevel: 'verified_to_premise_level',
    VerifiedToSuiteLevel: 'verified_to_suite_level',
    CodedToStreetLavel: 'coded_to_street_lavel',
    CodedToNeighborhoodLevel: 'coded_to_neighborhood_level',
    CodedToCommunityLevel: 'coded_to_community_level',
    CodedToStateLevel: 'coded_to_state_level',
    CodedToRooftopLevel: 'coded_to_rooftop_level',
    CodedToRooftopInterpolationLevel: 'coded_to_rooftop_interpolation_level',
    NameMaxLengthExceeded: 'name_max_length_exceeded',
    PhoneMaxLengthExceeded: 'phone_max_length_exceeded',
    CompanyNameMaxLengthExceeded: 'company_name_max_length_exceeded',
    Line1MinMaxLength: 'line1_min_max_length',
    Line2MaxLengthExceeded: 'line2_max_length_exceeded',
    Line3MaxLengthExceeded: 'line3_max_length_exceeded',
    CityLocalityMaxLengthExceeded: 'city_locality_max_length_exceeded',
    StateProvinceMaxLengthExceeded: 'state_province_max_length_exceeded',
    InvalidPostalCode: 'invalid_postal_code',
    CountryInvalidLength: 'country_invalid_length',
    AddressNotFound: 'address_not_found'
};
/**
 * The different types of messages that can be returned by the address validation API
 * @export
 * @enum {string}
 */
exports.AddressValidationMessageType = {
    Error: 'error',
    Warning: 'warning',
    Info: 'info'
};
/**
 * The possible address validation status values
 * @export
 * @enum {string}
 */
exports.AddressValidationStatus = {
    Unverified: 'unverified',
    Verified: 'verified',
    Warning: 'warning',
    Error: 'error'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AllowedIncoterms = {
    Exw: 'exw',
    Fca: 'fca',
    Cpt: 'cpt',
    Cip: 'cip',
    Dpu: 'dpu',
    Dap: 'dap',
    Ddp: 'ddp',
    Fas: 'fas',
    Fob: 'fob',
    Cfr: 'cfr',
    Cif: 'cif',
    Ddu: 'ddu',
    Daf: 'daf',
    Deq: 'deq',
    Des: 'des'
};
/**
 * [Ancillary service endorsements](https://pe.usps.com/text/qsg300/Q507.htm) are used by mailers to request an addressee\'s new address and to provide the carrier with instructions on how to handle packages that are undeliverable as addressed.  | Ancillary Service Endorsement  | Description |--------------------------------|----------------------------------------------------- | `none`                         | No ancillary service is requested. Depending on the carrier servive, the package may be forwarded, returned, or discarded. | `return_service_requested`     | The package is returned to the sender. If possible, notification of the new address is is included with the returned package. | `forwarding_service_requested` | Forward the package to the new address, if possible; otherwise, return it to the sender. | `address_service_requested`    | Forward the package to the new address, if possible; otherwise, return it to the sender. This is similar to `forwarding_service_requested`, but different restrictions and charges may apply. | `change_service_requested`     | The package is discarded. If possible, notification of the new address is sent to the sender. | `leave_if_no_response`         |
 * @export
 * @enum {string}
 */
exports.AncillaryServiceEndorsement = {
    None: 'none',
    ReturnServiceRequested: 'return_service_requested',
    ForwardingServiceRequested: 'forwarding_service_requested',
    AddressServiceRequested: 'address_service_requested',
    ChangeServiceRequested: 'change_service_requested',
    LeaveIfNoResponse: 'leave_if_no_response'
};
/**
 * The possible batch status values
 * @export
 * @enum {string}
 */
exports.BatchStatus = {
    Open: 'open',
    Queued: 'queued',
    Processing: 'processing',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors',
    Archived: 'archived',
    Notifying: 'notifying',
    Invalid: 'invalid'
};
/**
 * The possible batches sort by values
 * @export
 * @enum {string}
 */
exports.BatchesSortBy = {
    ShipDate: 'ship_date',
    ProcessedAt: 'processed_at',
    CreatedAt: 'created_at'
};
/**
 * The possible bill to party values
 * @export
 * @enum {string}
 */
exports.BillToParty = {
    Recipient: 'recipient',
    ThirdParty: 'third_party'
};
/**
 * The shipping carriers that are supported by ShipEngine
 * @export
 * @enum {string}
 */
exports.CarrierName = {
    AccessWorldwide: 'access_worldwide',
    AmazonBuyShipping: 'amazon_buy_shipping',
    AmazonShippingUk: 'amazon_shipping_uk',
    Apc: 'apc',
    Asendia: 'asendia',
    AustraliaPost: 'australia_post',
    CanadaPost: 'canada_post',
    DhlEcommerce: 'dhl_ecommerce',
    DhlExpress: 'dhl_express',
    DhlExpressAu: 'dhl_express_au',
    DhlExpressCa: 'dhl_express_ca',
    DhlExpressUk: 'dhl_express_uk',
    Dpd: 'dpd',
    Endicia: 'endicia',
    Fedex: 'fedex',
    FedexUk: 'fedex_uk',
    Firstmile: 'firstmile',
    Imex: 'imex',
    Newgistics: 'newgistics',
    Ontrac: 'ontrac',
    PurolatorCanada: 'purolator_canada',
    RoyalMail: 'royal_mail',
    RrDonnelley: 'rr_donnelley',
    Seko: 'seko',
    Sendle: 'sendle',
    StampsCom: 'stamps_com',
    Ups: 'ups'
};
/**
 * The shipping carriers for which ShipEngine supports carrier settings
 * @export
 * @enum {string}
 */
exports.CarrierNameWithSettings = {
    DhlExpress: 'dhl_express',
    Fedex: 'fedex',
    Newgistics: 'newgistics',
    Ups: 'ups'
};
/**
 * Types of payment that are supported
 * @export
 * @enum {string}
 */
exports.CollectOnDeliveryPaymentType = {
    Any: 'any',
    Cash: 'cash',
    CashEquivalent: 'cash_equivalent',
    None: 'none'
};
exports.CreateAccountSettingsImageRequestBodyImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
/**
 * The possible default label layout values
 * @export
 * @enum {string}
 */
exports.DefaultLabelLayout = {
    _4x6: '4x6',
    Letter: 'Letter'
};
/**
 * The possible delivery confirmation values
 * @export
 * @enum {string}
 */
exports.DeliveryConfirmation = {
    None: 'none',
    Delivery: 'delivery',
    Signature: 'signature',
    AdultSignature: 'adult_signature',
    DirectSignature: 'direct_signature',
    DeliveryMailed: 'delivery_mailed',
    VerbalConfirmation: 'verbal_confirmation'
};
/**
 * The dimension units that are supported by ShipEngine.
 * @export
 * @enum {string}
 */
exports.DimensionUnit = {
    Inch: 'inch',
    Centimeter: 'centimeter'
};
/**
 * The display format that the label should be shown in.
 * @export
 * @enum {string}
 */
exports.DisplayScheme = {
    Label: 'label',
    QrCode: 'qr_code',
    LabelAndQrCode: 'label_and_qr_code'
};
/**
 * The error code specified for the failed API Call
 * @export
 * @enum {string}
 */
exports.ErrorCode = {
    AutoFundNotSupported: 'auto_fund_not_supported',
    BatchCannotBeModified: 'batch_cannot_be_modified',
    CarrierConflict: 'carrier_conflict',
    CarrierDisconnected: 'carrier_disconnected',
    CarrierNotConnected: 'carrier_not_connected',
    CarrierNotSupported: 'carrier_not_supported',
    ConfirmationNotSupported: 'confirmation_not_supported',
    DefaultWarehouseCannotBeDeleted: 'default_warehouse_cannot_be_deleted',
    FieldConflict: 'field_conflict',
    FieldValueRequired: 'field_value_required',
    Forbidden: 'forbidden',
    IdentifierConflict: 'identifier_conflict',
    IdentifiersMustMatch: 'identifiers_must_match',
    InsufficientFunds: 'insufficient_funds',
    InvalidAddress: 'invalid_address',
    InvalidBillingPlan: 'invalid_billing_plan',
    InvalidFieldValue: 'invalid_field_value',
    InvalidIdentifier: 'invalid_identifier',
    InvalidStatus: 'invalid_status',
    InvalidStringLength: 'invalid_string_length',
    LabelImagesNotSupported: 'label_images_not_supported',
    MeterFailure: 'meter_failure',
    OrderSourceNotActive: 'order_source_not_active',
    RateLimitExceeded: 'rate_limit_exceeded',
    RefreshNotSupported: 'refresh_not_supported',
    RequestBodyRequired: 'request_body_required',
    ReturnLabelNotSupported: 'return_label_not_supported',
    SettingsNotSupported: 'settings_not_supported',
    SubscriptionInactive: 'subscription_inactive',
    TermsNotAccepted: 'terms_not_accepted',
    TrackingNotSupported: 'tracking_not_supported',
    TrialExpired: 'trial_expired',
    Unauthorized: 'unauthorized',
    Unknown: 'unknown',
    Unspecified: 'unspecified',
    VerificationFailure: 'verification_failure',
    WarehouseConflict: 'warehouse_conflict',
    WebhookEventTypeConflict: 'webhook_event_type_conflict'
};
/**
 * The source of the error, as indicated by the name this informs us if the API call failed because of the carrier, the order source, or the ShipEngine API itself.
 * @export
 * @enum {string}
 */
exports.ErrorSource = {
    Carrier: 'carrier',
    OrderSource: 'order_source',
    Shipengine: 'shipengine'
};
/**
 * The type of error
 * @export
 * @enum {string}
 */
exports.ErrorType = {
    AccountStatus: 'account_status',
    BusinessRules: 'business_rules',
    Validation: 'validation',
    Security: 'security',
    System: 'system',
    Integrations: 'integrations'
};
/**
 * Determines how FedEx will pickup your packages  |Pickup Type               |Description |--------------------------|----------------------------------------- |`none`                    | Not specified |`regular_pickup`          | You already have a daily pickup scheduled with FedEx |`request_courier`         | You will call FedEx to request a courier |`drop_box`                | You will drop-off packages in a FedEx drop box |`business_service_center` | You will drop-off packages at an authorized FedEx business service center |`station`                 | You will drop-off the package at a FedEx Station
 * @export
 * @enum {string}
 */
exports.FedexPickupType = {
    None: 'none',
    RegularPickup: 'regular_pickup',
    RequestCourier: 'request_courier',
    DropBox: 'drop_box',
    BusinessServiceCenter: 'business_service_center',
    Station: 'station'
};
exports.GetAccountSettingsImagesResponseBodyImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
exports.GetServicePointByIdResponseBodyServicePointFeaturesEnum = {
    DropOffPoint: 'drop_off_point',
    PickupPoint: 'pickup_point',
    PrintServices: 'print_services',
    AfterHoursLocker: 'after_hours_locker',
    AfterHoursDropbox: 'after_hours_dropbox'
};
exports.GetServicePointByIdResponseBodyServicePointTypeEnum = {
    Pudo: 'pudo',
    Locker: 'locker'
};
/**
 * Determines how FedEx will pickup your packages  |Pickup Type    | Description |---------------|----------------------------------------- |`vat`          | The tax identifier is a Value Added Tax. |`eori`         | The tax identifier is an Economic Operators Registration and Identification Number (EORI). |`ssn`          | The tax identifier is a Social Security Number. |`ein`          | The tax identifier is an Employer Identification Number (EIN). |`tin`          | The tax identifier is a Tax Identification Number (TIN). |`ioss`         | The tax identifier is an Import One-Stop Shop (IOSS). |`pan`          | The tax identifier is a Permanent Account Number (PAN). |`voec`         | The tax identifier is a Norwegian VAT On E-Commerce(VOEC). |`pccc`         | The tax identifier is a Personal Customs Clearance Code (PCCC). |`oss`          | The tax identifier is an One-Stop Shop (OSS). |`passport`     | The tax identifier is a Passport Number. |`abn`          | The tax identifier is an Australian Business Number.
 * @export
 * @enum {string}
 */
exports.IdentifierType = {
    Vat: 'vat',
    Eori: 'eori',
    Ssn: 'ssn',
    Ein: 'ein',
    Tin: 'tin',
    Ioss: 'ioss',
    Pan: 'pan',
    Voec: 'voec',
    Pccc: 'pccc',
    Oss: 'oss',
    Passport: 'passport',
    Abn: 'abn'
};
/**
 * The possible insurance provider values
 * @export
 * @enum {string}
 */
exports.InsuranceProvider = {
    None: 'none',
    Shipsurance: 'shipsurance',
    Carrier: 'carrier',
    ThirdParty: 'third_party'
};
/**
 * Determines when the user\'s account will be charged for the label.
 * @export
 * @enum {string}
 */
exports.LabelChargeEvent = {
    CarrierDefault: 'carrier_default',
    OnCreation: 'on_creation',
    OnCarrierAcceptance: 'on_carrier_acceptance'
};
/**
 * There are two different ways to [download a label](https://www.shipengine.com/docs/labels/downloading/):  |Label Download Type | Description |--------------------|------------------------------ |`url`               |You will receive a URL, which you can use to download the label in a separate request. The URL will remain valid for 90 days.<br><br>This is the default if `label_download_type` is unspecified. |`inline`            |You will receive the Base64-encoded label as part of the response. No need for a second request to download the label.
 * @export
 * @enum {string}
 */
exports.LabelDownloadType = {
    Url: 'url',
    Inline: 'inline'
};
/**
 * The possible file formats in which shipping labels can be downloaded.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.  |Label Format  | Supported Carriers |--------------|----------------------------------- |`pdf`         | All carriers |`png`         | `fedex` <br> `stamps_com` <br> `ups` <br> `usps` |`zpl`         | `access_worldwide` <br> `apc` <br> `asendia` <br> `dhl_global_mail` <br> `dhl_express` <br> `dhl_express_australia` <br> `dhl_express_canada` <br> `dhl_express_worldwide` <br> `dhl_express_uk` <br> `dpd` <br> `endicia` <br> `fedex` <br> `fedex_uk` <br> `firstmile` <br> `imex` <br> `newgistics` <br> `ontrac` <br> `rr_donnelley` <br> `stamps_com` <br> `ups` <br> `usps`
 * @export
 * @enum {string}
 */
exports.LabelFormat = {
    Pdf: 'pdf',
    Png: 'png',
    Zpl: 'zpl'
};
/**
 * The available layouts (sizes) in which shipping labels can be downloaded.  The label format determines which sizes are supported.  `4x6` is supported for all label formats, whereas `letter` (8.5\" x 11\") is only supported for `pdf` format.
 * @export
 * @enum {string}
 */
exports.LabelLayout = {
    _4x6: '4x6',
    Letter: 'letter'
};
/**
 * The possible statuses that a [shipping label](https://www.shipengine.com/docs/labels/create-a-label/) can be in.  |Status       |Description |:------------|:----------------------------------------------------- |`processing` |When labels are created in a [batch](https://www.shipengine.com/docs/labels/bulk/), it may take a few minutes for all of the labels in the batch to be created.  During this period, they will be in `processing` status. |`completed`  |The label was successfully created |`error`      |The label could not be created due to an error, such as an invalid delivery address |`voided`     |The label has been [voided](https://www.shipengine.com/docs/labels/voiding/)
 * @export
 * @enum {string}
 */
exports.LabelStatus = {
    Processing: 'processing',
    Completed: 'completed',
    Error: 'error',
    Voided: 'voided'
};
exports.ListServicePointsResponseBodyServicePointsInnerFeaturesEnum = {
    DropOffPoint: 'drop_off_point',
    PickupPoint: 'pickup_point',
    PrintServices: 'print_services',
    AfterHoursLocker: 'after_hours_locker',
    AfterHoursDropbox: 'after_hours_dropbox'
};
exports.ListServicePointsResponseBodyServicePointsInnerTypeEnum = {
    Pudo: 'pudo',
    Locker: 'locker'
};
/**
 * The possible statuses of a manifest request
 * @export
 * @enum {string}
 */
exports.ManifestRequestStatus = {
    InProgress: 'in_progress',
    Completed: 'completed'
};
/**
 * The possible non delivery values
 * @export
 * @enum {string}
 */
exports.NonDelivery = {
    ReturnToSender: 'return_to_sender',
    TreatAsAbandoned: 'treat_as_abandoned'
};
/**
 * The order sources that are supported by ShipEngine
 * @export
 * @enum {string}
 */
exports.OrderSourceName = {
    AmazonCa: 'amazon_ca',
    AmazonUs: 'amazon_us',
    Brightpearl: 'brightpearl',
    ChannelAdvisor: 'channel_advisor',
    Cratejoy: 'cratejoy',
    Ebay: 'ebay',
    Etsy: 'etsy',
    Jane: 'jane',
    GrouponGoods: 'groupon_goods',
    Magento: 'magento',
    Paypal: 'paypal',
    SellerActive: 'seller_active',
    Shopify: 'shopify',
    StitchLabs: 'stitch_labs',
    Squarespace: 'squarespace',
    ThreeDcart: 'three_dcart',
    Tophatter: 'tophatter',
    Walmart: 'walmart',
    WooCommerce: 'woo_commerce',
    Volusion: 'volusion'
};
/**
 * Indicates if the package will be picked up or dropped off by the carrier
 * @export
 * @enum {string}
 */
exports.OriginType = {
    Pickup: 'pickup',
    DropOff: 'drop_off'
};
/**
 * The possible package contents values
 * @export
 * @enum {string}
 */
exports.PackageContents = {
    Merchandise: 'merchandise',
    Documents: 'documents',
    Gift: 'gift',
    ReturnedGoods: 'returned_goods',
    Sample: 'sample',
    Other: 'other'
};
/**
 * The possible rate response status values
 * @export
 * @enum {string}
 */
exports.RateResponseStatus = {
    Working: 'working',
    Completed: 'completed',
    Partial: 'partial',
    Error: 'error'
};
/**
 * The possible rate type values
 * @export
 * @enum {string}
 */
exports.RateType = {
    Check: 'check',
    Shipment: 'shipment'
};
/**
 * The possible normalized reasons a label void request may not have been approved
 * @export
 * @enum {string}
 */
exports.ReasonCode = {
    Unknown: 'unknown',
    Unspecified: 'unspecified',
    ValidationFailed: 'validation_failed',
    LabelNotFoundWithinVoidPeriod: 'label_not_found_within_void_period',
    LabelAlreadyUsed: 'label_already_used',
    LabelAlreadyVoided: 'label_already_voided',
    ContactCarrier: 'contact_carrier'
};
/**
 * The resource to return a redirect URL to.
 * @export
 * @enum {string}
 */
exports.Redirect = {
    ShipengineDashboard: 'shipengine-dashboard'
};
/**
 * The possible shipment status values
 * @export
 * @enum {string}
 */
exports.ShipmentStatus = {
    Pending: 'pending',
    Processing: 'processing',
    LabelPurchased: 'label_purchased',
    Cancelled: 'cancelled'
};
/**
 * The possible shipments sort by values
 * @export
 * @enum {string}
 */
exports.ShipmentsSortBy = {
    ModifiedAt: 'modified_at',
    CreatedAt: 'created_at'
};
/**
 * The possible smart post hub values
 * @export
 * @enum {string}
 */
exports.SmartPostHub = {
    None: 'none',
    AllentownPa: 'allentown_pa',
    AtlantaGa: 'atlanta_ga',
    BaltimoreMd: 'baltimore_md',
    CharlotteNc: 'charlotte_nc',
    ChinoCa: 'chino_ca',
    DallasTx: 'dallas_tx',
    DenverCo: 'denver_co',
    DetroitMi: 'detroit_mi',
    EdisonNj: 'edison_nj',
    GroveCityOh: 'grove_city_oh',
    GroveportOh: 'groveport_oh',
    HoustonTx: 'houston_tx',
    IndianapolisIn: 'indianapolis_in',
    KansasCityKs: 'kansas_city_ks',
    LosAngelesCa: 'los_angeles_ca',
    MartinsburgWv: 'martinsburg_wv',
    MemphisTn: 'memphis_tn',
    MinneapolisMn: 'minneapolis_mn',
    NewBerlinWi: 'new_berlin_wi',
    NorthboroughMa: 'northborough_ma',
    OrlandoFl: 'orlando_fl',
    PhoneixAz: 'phoneix_az',
    PittsburghPa: 'pittsburgh_pa',
    RenoNv: 'reno_nv',
    SacramentoCa: 'sacramento_ca',
    SaltLakeCityUt: 'salt_lake_city_ut',
    SeattleWa: 'seattle_wa',
    StLouisMo: 'st_louis_mo',
    WindsorCt: 'windsor_ct',
    NewarkNy: 'newark_ny',
    SouthBrunswickNj: 'south_brunswick_nj',
    ScrantonPa: 'scranton_pa',
    WheelingIl: 'wheeling_il'
};
/**
 * Controls the sort order of queries  |Value     |Description |:---------|:----------------------------------------------------- |`asc`     |Return results in ascending order |`desc`    |Return results in descending order
 * @export
 * @enum {string}
 */
exports.SortDir = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * The tracking status codes  |Value       |Description |:---------  |:----------------------------------------------------- |`un` | Unknown |`ac` | Accepted |`it` | In Transit |`de` | Delivered |`ex` | Exception |`at` | Delivery Attempt |`ny` | Not Yet In System
 * @export
 * @enum {string}
 */
exports.StatusCode = {
    Un: 'un',
    Ac: 'ac',
    It: 'it',
    De: 'de',
    Ex: 'ex',
    At: 'at',
    Ny: 'ny'
};
/**
 * The taxable entity type for this tax item. Valid values include the following  |Value       |Description |:---------  |:----------------------------------------------------- |`shipper`   | The shipper is responsible for this tax. |`recipient` | The recipient of the shipment is responsible for this tax. |`ior`       | The importer of records is responsible for tax.
 * @export
 * @enum {string}
 */
exports.TaxableEntityType = {
    Shipper: 'shipper',
    Recipient: 'recipient',
    Ior: 'ior'
};
/**
 * The different statuses that can apply to a shipment.
 * @export
 * @enum {string}
 */
exports.TrackingStatus = {
    Unknown: 'unknown',
    InTransit: 'in_transit',
    Error: 'error',
    Delivered: 'delivered'
};
exports.UpdateAccountSettingsImageRequestBodyImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
/**
 * The possible ups pickup type values
 * @export
 * @enum {string}
 */
exports.UpsPickupType = {
    DailyPickup: 'daily_pickup',
    OccasionalPickup: 'occasional_pickup',
    CustomerCounter: 'customer_counter'
};
/**
 * The possible validate address values
 * @export
 * @enum {string}
 */
exports.ValidateAddress = {
    NoValidation: 'no_validation',
    ValidateOnly: 'validate_only',
    ValidateAndClean: 'validate_and_clean'
};
/**
 * The possible validation status values
 * @export
 * @enum {string}
 */
exports.ValidationStatus = {
    Valid: 'valid',
    Invalid: 'invalid',
    HasWarnings: 'has_warnings',
    Unknown: 'unknown'
};
/**
 * The possible webook event values
 * @export
 * @enum {string}
 */
exports.WebhookEvent = {
    Batch: 'batch',
    CarrierConnected: 'carrier_connected',
    OrderSourceRefreshComplete: 'order_source_refresh_complete',
    Rate: 'rate',
    ReportComplete: 'report_complete',
    SalesOrdersImported: 'sales_orders_imported',
    Track: 'track'
};
/**
 * The possible weight unit values
 * @export
 * @enum {string}
 */
exports.WeightUnit = {
    Pound: 'pound',
    Ounce: 'ounce',
    Gram: 'gram',
    Kilogram: 'kilogram'
};
/**
 * AccountApi - axios parameter creator
 * @export
 */
const AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create an Account Image
         * @summary Create an Account Image
         * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountImage: (createAccountSettingsImageRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createAccountSettingsImageRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createAccountImage', 'createAccountSettingsImageRequestBody', createAccountSettingsImageRequestBody);
            const localVarPath = `/v1/account/settings/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAccountSettingsImageRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete Account Image By Id
         * @summary Delete Account Image By Id
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountImageById: (labelImageId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelImageId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAccountImageById', 'labelImageId', labelImageId);
            const localVarPath = `/v1/account/settings/images/{label_image_id}`
                .replace(`{${"label_image_id"}}`, encodeURIComponent(String(labelImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve information for an account image.
         * @summary Get Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettingsImagesById: (labelImageId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelImageId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountSettingsImagesById', 'labelImageId', labelImageId);
            const localVarPath = `/v1/account/settings/images/{label_image_id}`
                .replace(`{${"label_image_id"}}`, encodeURIComponent(String(labelImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all account images for the ShipEngine account
         * @summary List Account Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountImages: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/account/settings/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all account settings for the ShipEngine account
         * @summary List Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountSettings: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/account/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update information for an account image.
         * @summary Update Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettingsImagesById: (labelImageId, updateAccountSettingsImageRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelImageId' is not null or undefined
            (0, common_1.assertParamExists)('updateAccountSettingsImagesById', 'labelImageId', labelImageId);
            // verify required parameter 'updateAccountSettingsImageRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updateAccountSettingsImagesById', 'updateAccountSettingsImageRequestBody', updateAccountSettingsImageRequestBody);
            const localVarPath = `/v1/account/settings/images/{label_image_id}`
                .replace(`{${"label_image_id"}}`, encodeURIComponent(String(labelImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateAccountSettingsImageRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountApiAxiosParamCreator = AccountApiAxiosParamCreator;
/**
 * AccountApi - functional programming interface
 * @export
 */
const AccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create an Account Image
         * @summary Create an Account Image
         * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountImage(createAccountSettingsImageRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAccountImage(createAccountSettingsImageRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete Account Image By Id
         * @summary Delete Account Image By Id
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountImageById(labelImageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAccountImageById(labelImageId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve information for an account image.
         * @summary Get Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettingsImagesById(labelImageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountSettingsImagesById(labelImageId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List all account images for the ShipEngine account
         * @summary List Account Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountImages(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAccountImages(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List all account settings for the ShipEngine account
         * @summary List Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountSettings(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAccountSettings(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update information for an account image.
         * @summary Update Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountApiFp = AccountApiFp;
/**
 * AccountApi - factory interface
 * @export
 */
const AccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountApiFp)(configuration);
    return {
        /**
         * Create an Account Image
         * @summary Create an Account Image
         * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountImage(createAccountSettingsImageRequestBody, options) {
            return localVarFp.createAccountImage(createAccountSettingsImageRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Account Image By Id
         * @summary Delete Account Image By Id
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountImageById(labelImageId, options) {
            return localVarFp.deleteAccountImageById(labelImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for an account image.
         * @summary Get Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettingsImagesById(labelImageId, options) {
            return localVarFp.getAccountSettingsImagesById(labelImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all account images for the ShipEngine account
         * @summary List Account Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountImages(options) {
            return localVarFp.listAccountImages(options).then((request) => request(axios, basePath));
        },
        /**
         * List all account settings for the ShipEngine account
         * @summary List Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountSettings(options) {
            return localVarFp.listAccountSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for an account image.
         * @summary Update Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options) {
            return localVarFp.updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
class AccountApi extends base_1.BaseAPI {
    /**
     * Create an Account Image
     * @summary Create an Account Image
     * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    createAccountImage(createAccountSettingsImageRequestBody, options) {
        return (0, exports.AccountApiFp)(this.configuration).createAccountImage(createAccountSettingsImageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete Account Image By Id
     * @summary Delete Account Image By Id
     * @param {string} labelImageId Label Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    deleteAccountImageById(labelImageId, options) {
        return (0, exports.AccountApiFp)(this.configuration).deleteAccountImageById(labelImageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve information for an account image.
     * @summary Get Account Image By ID
     * @param {string} labelImageId Label Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountSettingsImagesById(labelImageId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountSettingsImagesById(labelImageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all account images for the ShipEngine account
     * @summary List Account Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    listAccountImages(options) {
        return (0, exports.AccountApiFp)(this.configuration).listAccountImages(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all account settings for the ShipEngine account
     * @summary List Account Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    listAccountSettings(options) {
        return (0, exports.AccountApiFp)(this.configuration).listAccountSettings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update information for an account image.
     * @summary Update Account Image By ID
     * @param {string} labelImageId Label Image Id
     * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options) {
        return (0, exports.AccountApiFp)(this.configuration).updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountApi = AccountApi;
/**
 * AddressesApi - axios parameter creator
 * @export
 */
const AddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse an address
         * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseAddress: (parseAddressRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'parseAddressRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('parseAddress', 'parseAddressRequestBody', parseAddressRequestBody);
            const localVarPath = `/v1/addresses/recognize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(parseAddressRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
         * @summary Validate An Address
         * @param {Array<AddressToValidate>} addressToValidate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: (addressToValidate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'addressToValidate' is not null or undefined
            (0, common_1.assertParamExists)('validateAddress', 'addressToValidate', addressToValidate);
            const localVarPath = `/v1/addresses/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addressToValidate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;
/**
 * AddressesApi - functional programming interface
 * @export
 */
const AddressesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AddressesApiAxiosParamCreator)(configuration);
    return {
        /**
         * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse an address
         * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseAddress(parseAddressRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.parseAddress(parseAddressRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
         * @summary Validate An Address
         * @param {Array<AddressToValidate>} addressToValidate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress(addressToValidate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validateAddress(addressToValidate, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AddressesApiFp = AddressesApiFp;
/**
 * AddressesApi - factory interface
 * @export
 */
const AddressesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AddressesApiFp)(configuration);
    return {
        /**
         * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse an address
         * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseAddress(parseAddressRequestBody, options) {
            return localVarFp.parseAddress(parseAddressRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
         * @summary Validate An Address
         * @param {Array<AddressToValidate>} addressToValidate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress(addressToValidate, options) {
            return localVarFp.validateAddress(addressToValidate, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AddressesApiFactory = AddressesApiFactory;
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
class AddressesApi extends base_1.BaseAPI {
    /**
     * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
     * @summary Parse an address
     * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    parseAddress(parseAddressRequestBody, options) {
        return (0, exports.AddressesApiFp)(this.configuration).parseAddress(parseAddressRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
     * @summary Validate An Address
     * @param {Array<AddressToValidate>} addressToValidate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    validateAddress(addressToValidate, options) {
        return (0, exports.AddressesApiFp)(this.configuration).validateAddress(addressToValidate, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AddressesApi = AddressesApi;
/**
 * BatchesApi - axios parameter creator
 * @export
 */
const BatchesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a Shipment or Rate to a Batch
         * @summary Add to a Batch
         * @param {string} batchId Batch ID
         * @param {AddToBatchRequestBody} addToBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch: (batchId, addToBatchRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('addToBatch', 'batchId', batchId);
            // verify required parameter 'addToBatchRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('addToBatch', 'addToBatchRequestBody', addToBatchRequestBody);
            const localVarPath = `/v1/batches/{batch_id}/add`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addToBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a Batch
         * @summary Create A Batch
         * @param {CreateBatchRequestBody} createBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: (createBatchRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createBatchRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createBatch', 'createBatchRequestBody', createBatchRequestBody);
            const localVarPath = `/v1/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete Batch By Id
         * @summary Delete Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch: (batchId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('deleteBatch', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Batch By External ID
         * @summary Get Batch By External ID
         * @param {string} externalBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId: (externalBatchId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'externalBatchId' is not null or undefined
            (0, common_1.assertParamExists)('getBatchByExternalId', 'externalBatchId', externalBatchId);
            const localVarPath = `/v1/batches/external_batch_id/{external_batch_id}`
                .replace(`{${"external_batch_id"}}`, encodeURIComponent(String(externalBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Batch By ID
         * @summary Get Batch By ID
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById: (batchId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('getBatchById', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
         * @summary Get Batch Errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pagesize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors: (batchId, page, pagesize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('listBatchErrors', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}/errors`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Batches associated with your Shipengine account
         * @summary List Batches
         * @param {BatchStatus} [status]
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches: (status, page, pageSize, sortDir, batchNumber, sortBy, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }
            if (batchNumber !== undefined) {
                localVarQueryParameter['batch_number'] = batchNumber;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Process Batch ID Labels
         * @summary Process Batch ID Labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch: (batchId, processBatchRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('processBatch', 'batchId', batchId);
            // verify required parameter 'processBatchRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('processBatch', 'processBatchRequestBody', processBatchRequestBody);
            const localVarPath = `/v1/batches/{batch_id}/process/labels`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Remove a shipment or rate from a batch
         * @summary Remove From Batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch: (batchId, removeFromBatchRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('removeFromBatch', 'batchId', batchId);
            // verify required parameter 'removeFromBatchRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('removeFromBatch', 'removeFromBatchRequestBody', removeFromBatchRequestBody);
            const localVarPath = `/v1/batches/{batch_id}/remove`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeFromBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update Batch By Id
         * @summary Update Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch: (batchId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchId' is not null or undefined
            (0, common_1.assertParamExists)('updateBatch', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BatchesApiAxiosParamCreator = BatchesApiAxiosParamCreator;
/**
 * BatchesApi - functional programming interface
 * @export
 */
const BatchesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BatchesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add a Shipment or Rate to a Batch
         * @summary Add to a Batch
         * @param {string} batchId Batch ID
         * @param {AddToBatchRequestBody} addToBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch(batchId, addToBatchRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addToBatch(batchId, addToBatchRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a Batch
         * @summary Create A Batch
         * @param {CreateBatchRequestBody} createBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(createBatchRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBatch(createBatchRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete Batch By Id
         * @summary Delete Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBatch(batchId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Batch By External ID
         * @summary Get Batch By External ID
         * @param {string} externalBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId(externalBatchId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBatchByExternalId(externalBatchId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Batch By ID
         * @summary Get Batch By ID
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById(batchId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBatchById(batchId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
         * @summary Get Batch Errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pagesize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors(batchId, page, pagesize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBatchErrors(batchId, page, pagesize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List Batches associated with your Shipengine account
         * @summary List Batches
         * @param {BatchStatus} [status]
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Process Batch ID Labels
         * @summary Process Batch ID Labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch(batchId, processBatchRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.processBatch(batchId, processBatchRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Remove a shipment or rate from a batch
         * @summary Remove From Batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch(batchId, removeFromBatchRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeFromBatch(batchId, removeFromBatchRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update Batch By Id
         * @summary Update Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBatch(batchId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.BatchesApiFp = BatchesApiFp;
/**
 * BatchesApi - factory interface
 * @export
 */
const BatchesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BatchesApiFp)(configuration);
    return {
        /**
         * Add a Shipment or Rate to a Batch
         * @summary Add to a Batch
         * @param {string} batchId Batch ID
         * @param {AddToBatchRequestBody} addToBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch(batchId, addToBatchRequestBody, options) {
            return localVarFp.addToBatch(batchId, addToBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Batch
         * @summary Create A Batch
         * @param {CreateBatchRequestBody} createBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(createBatchRequestBody, options) {
            return localVarFp.createBatch(createBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Batch By Id
         * @summary Delete Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId, options) {
            return localVarFp.deleteBatch(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Batch By External ID
         * @summary Get Batch By External ID
         * @param {string} externalBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId(externalBatchId, options) {
            return localVarFp.getBatchByExternalId(externalBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Batch By ID
         * @summary Get Batch By ID
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById(batchId, options) {
            return localVarFp.getBatchById(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
         * @summary Get Batch Errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pagesize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors(batchId, page, pagesize, options) {
            return localVarFp.listBatchErrors(batchId, page, pagesize, options).then((request) => request(axios, basePath));
        },
        /**
         * List Batches associated with your Shipengine account
         * @summary List Batches
         * @param {BatchStatus} [status]
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options) {
            return localVarFp.listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Process Batch ID Labels
         * @summary Process Batch ID Labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch(batchId, processBatchRequestBody, options) {
            return localVarFp.processBatch(batchId, processBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a shipment or rate from a batch
         * @summary Remove From Batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch(batchId, removeFromBatchRequestBody, options) {
            return localVarFp.removeFromBatch(batchId, removeFromBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Batch By Id
         * @summary Update Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId, options) {
            return localVarFp.updateBatch(batchId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BatchesApiFactory = BatchesApiFactory;
/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
class BatchesApi extends base_1.BaseAPI {
    /**
     * Add a Shipment or Rate to a Batch
     * @summary Add to a Batch
     * @param {string} batchId Batch ID
     * @param {AddToBatchRequestBody} addToBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    addToBatch(batchId, addToBatchRequestBody, options) {
        return (0, exports.BatchesApiFp)(this.configuration).addToBatch(batchId, addToBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a Batch
     * @summary Create A Batch
     * @param {CreateBatchRequestBody} createBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    createBatch(createBatchRequestBody, options) {
        return (0, exports.BatchesApiFp)(this.configuration).createBatch(createBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete Batch By Id
     * @summary Delete Batch By Id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    deleteBatch(batchId, options) {
        return (0, exports.BatchesApiFp)(this.configuration).deleteBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Batch By External ID
     * @summary Get Batch By External ID
     * @param {string} externalBatchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    getBatchByExternalId(externalBatchId, options) {
        return (0, exports.BatchesApiFp)(this.configuration).getBatchByExternalId(externalBatchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Batch By ID
     * @summary Get Batch By ID
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    getBatchById(batchId, options) {
        return (0, exports.BatchesApiFp)(this.configuration).getBatchById(batchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
     * @summary Get Batch Errors
     * @param {string} batchId Batch ID
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pagesize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    listBatchErrors(batchId, page, pagesize, options) {
        return (0, exports.BatchesApiFp)(this.configuration).listBatchErrors(batchId, page, pagesize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Batches associated with your Shipengine account
     * @summary List Batches
     * @param {BatchStatus} [status]
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {string} [batchNumber] Batch Number
     * @param {BatchesSortBy} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options) {
        return (0, exports.BatchesApiFp)(this.configuration).listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Process Batch ID Labels
     * @summary Process Batch ID Labels
     * @param {string} batchId Batch ID
     * @param {ProcessBatchRequestBody} processBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    processBatch(batchId, processBatchRequestBody, options) {
        return (0, exports.BatchesApiFp)(this.configuration).processBatch(batchId, processBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove a shipment or rate from a batch
     * @summary Remove From Batch
     * @param {string} batchId Batch ID
     * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    removeFromBatch(batchId, removeFromBatchRequestBody, options) {
        return (0, exports.BatchesApiFp)(this.configuration).removeFromBatch(batchId, removeFromBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Batch By Id
     * @summary Update Batch By Id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    updateBatch(batchId, options) {
        return (0, exports.BatchesApiFp)(this.configuration).updateBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BatchesApi = BatchesApi;
/**
 * CarrierAccountsApi - axios parameter creator
 * @export
 */
const CarrierAccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Connect a carrier account
         * @summary Connect a carrier account
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCarrier: (carrierName, connectCarrierRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierName' is not null or undefined
            (0, common_1.assertParamExists)('connectCarrier', 'carrierName', carrierName);
            // verify required parameter 'connectCarrierRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('connectCarrier', 'connectCarrierRequestBody', connectCarrierRequestBody);
            const localVarPath = `/v1/connections/carriers/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(connectCarrierRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Disconnect a carrier
         * @summary Disconnect a carrier
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectCarrier: (carrierName, carrierId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierName' is not null or undefined
            (0, common_1.assertParamExists)('disconnectCarrier', 'carrierName', carrierName);
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('disconnectCarrier', 'carrierId', carrierId);
            const localVarPath = `/v1/connections/carriers/{carrier_name}/{carrier_id}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get carrier settings
         * @summary Get carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierSettings: (carrierName, carrierId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierName' is not null or undefined
            (0, common_1.assertParamExists)('getCarrierSettings', 'carrierName', carrierName);
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('getCarrierSettings', 'carrierId', carrierId);
            const localVarPath = `/v1/connections/carriers/{carrier_name}/{carrier_id}/settings`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update carrier settings
         * @summary Update carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCarrierSettings: (carrierName, carrierId, updateCarrierSettingsRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierName' is not null or undefined
            (0, common_1.assertParamExists)('updateCarrierSettings', 'carrierName', carrierName);
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('updateCarrierSettings', 'carrierId', carrierId);
            // verify required parameter 'updateCarrierSettingsRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updateCarrierSettings', 'updateCarrierSettingsRequestBody', updateCarrierSettingsRequestBody);
            const localVarPath = `/v1/connections/carriers/{carrier_name}/{carrier_id}/settings`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCarrierSettingsRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CarrierAccountsApiAxiosParamCreator = CarrierAccountsApiAxiosParamCreator;
/**
 * CarrierAccountsApi - functional programming interface
 * @export
 */
const CarrierAccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CarrierAccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Connect a carrier account
         * @summary Connect a carrier account
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCarrier(carrierName, connectCarrierRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.connectCarrier(carrierName, connectCarrierRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Disconnect a carrier
         * @summary Disconnect a carrier
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectCarrier(carrierName, carrierId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.disconnectCarrier(carrierName, carrierId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get carrier settings
         * @summary Get carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierSettings(carrierName, carrierId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCarrierSettings(carrierName, carrierId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update carrier settings
         * @summary Update carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CarrierAccountsApiFp = CarrierAccountsApiFp;
/**
 * CarrierAccountsApi - factory interface
 * @export
 */
const CarrierAccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CarrierAccountsApiFp)(configuration);
    return {
        /**
         * Connect a carrier account
         * @summary Connect a carrier account
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCarrier(carrierName, connectCarrierRequestBody, options) {
            return localVarFp.connectCarrier(carrierName, connectCarrierRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect a carrier
         * @summary Disconnect a carrier
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectCarrier(carrierName, carrierId, options) {
            return localVarFp.disconnectCarrier(carrierName, carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get carrier settings
         * @summary Get carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierSettings(carrierName, carrierId, options) {
            return localVarFp.getCarrierSettings(carrierName, carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update carrier settings
         * @summary Update carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options) {
            return localVarFp.updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CarrierAccountsApiFactory = CarrierAccountsApiFactory;
/**
 * CarrierAccountsApi - object-oriented interface
 * @export
 * @class CarrierAccountsApi
 * @extends {BaseAPI}
 */
class CarrierAccountsApi extends base_1.BaseAPI {
    /**
     * Connect a carrier account
     * @summary Connect a carrier account
     * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    connectCarrier(carrierName, connectCarrierRequestBody, options) {
        return (0, exports.CarrierAccountsApiFp)(this.configuration).connectCarrier(carrierName, connectCarrierRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disconnect a carrier
     * @summary Disconnect a carrier
     * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    disconnectCarrier(carrierName, carrierId, options) {
        return (0, exports.CarrierAccountsApiFp)(this.configuration).disconnectCarrier(carrierName, carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get carrier settings
     * @summary Get carrier settings
     * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    getCarrierSettings(carrierName, carrierId, options) {
        return (0, exports.CarrierAccountsApiFp)(this.configuration).getCarrierSettings(carrierName, carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update carrier settings
     * @summary Update carrier settings
     * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {string} carrierId Carrier ID
     * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options) {
        return (0, exports.CarrierAccountsApiFp)(this.configuration).updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CarrierAccountsApi = CarrierAccountsApi;
/**
 * CarriersApi - axios parameter creator
 * @export
 */
const CarriersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Funds To A Carrier
         * @summary Add Funds To Carrier
         * @param {string} carrierId Carrier ID
         * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToCarrier: (carrierId, addFundsToCarrierRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('addFundsToCarrier', 'carrierId', carrierId);
            // verify required parameter 'addFundsToCarrierRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('addFundsToCarrier', 'addFundsToCarrierRequestBody', addFundsToCarrierRequestBody);
            const localVarPath = `/v1/carriers/{carrier_id}/add_funds`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addFundsToCarrierRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrive carrier info by ID
         * @summary Get Carrier By ID
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierById: (carrierId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('getCarrierById', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of the options available for the carrier
         * @summary Get Carrier Options
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierOptions: (carrierId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('getCarrierOptions', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}/options`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the package types associated with the carrier
         * @summary List Carrier Package Types
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierPackageTypes: (carrierId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('listCarrierPackageTypes', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}/packages`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the services associated with the carrier ID
         * @summary List Carrier Services
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierServices: (carrierId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierId' is not null or undefined
            (0, common_1.assertParamExists)('listCarrierServices', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}/services`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all carriers that have been added to this account
         * @summary List Carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarriers: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CarriersApiAxiosParamCreator = CarriersApiAxiosParamCreator;
/**
 * CarriersApi - functional programming interface
 * @export
 */
const CarriersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CarriersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add Funds To A Carrier
         * @summary Add Funds To Carrier
         * @param {string} carrierId Carrier ID
         * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrive carrier info by ID
         * @summary Get Carrier By ID
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierById(carrierId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCarrierById(carrierId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get a list of the options available for the carrier
         * @summary Get Carrier Options
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierOptions(carrierId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCarrierOptions(carrierId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List the package types associated with the carrier
         * @summary List Carrier Package Types
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierPackageTypes(carrierId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCarrierPackageTypes(carrierId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List the services associated with the carrier ID
         * @summary List Carrier Services
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierServices(carrierId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCarrierServices(carrierId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List all carriers that have been added to this account
         * @summary List Carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarriers(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCarriers(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CarriersApiFp = CarriersApiFp;
/**
 * CarriersApi - factory interface
 * @export
 */
const CarriersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CarriersApiFp)(configuration);
    return {
        /**
         * Add Funds To A Carrier
         * @summary Add Funds To Carrier
         * @param {string} carrierId Carrier ID
         * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options) {
            return localVarFp.addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrive carrier info by ID
         * @summary Get Carrier By ID
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierById(carrierId, options) {
            return localVarFp.getCarrierById(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the options available for the carrier
         * @summary Get Carrier Options
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierOptions(carrierId, options) {
            return localVarFp.getCarrierOptions(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the package types associated with the carrier
         * @summary List Carrier Package Types
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierPackageTypes(carrierId, options) {
            return localVarFp.listCarrierPackageTypes(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the services associated with the carrier ID
         * @summary List Carrier Services
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierServices(carrierId, options) {
            return localVarFp.listCarrierServices(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all carriers that have been added to this account
         * @summary List Carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarriers(options) {
            return localVarFp.listCarriers(options).then((request) => request(axios, basePath));
        },
    };
};
exports.CarriersApiFactory = CarriersApiFactory;
/**
 * CarriersApi - object-oriented interface
 * @export
 * @class CarriersApi
 * @extends {BaseAPI}
 */
class CarriersApi extends base_1.BaseAPI {
    /**
     * Add Funds To A Carrier
     * @summary Add Funds To Carrier
     * @param {string} carrierId Carrier ID
     * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options) {
        return (0, exports.CarriersApiFp)(this.configuration).addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrive carrier info by ID
     * @summary Get Carrier By ID
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    getCarrierById(carrierId, options) {
        return (0, exports.CarriersApiFp)(this.configuration).getCarrierById(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of the options available for the carrier
     * @summary Get Carrier Options
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    getCarrierOptions(carrierId, options) {
        return (0, exports.CarriersApiFp)(this.configuration).getCarrierOptions(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the package types associated with the carrier
     * @summary List Carrier Package Types
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    listCarrierPackageTypes(carrierId, options) {
        return (0, exports.CarriersApiFp)(this.configuration).listCarrierPackageTypes(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the services associated with the carrier ID
     * @summary List Carrier Services
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    listCarrierServices(carrierId, options) {
        return (0, exports.CarriersApiFp)(this.configuration).listCarrierServices(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all carriers that have been added to this account
     * @summary List Carriers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    listCarriers(options) {
        return (0, exports.CarriersApiFp)(this.configuration).listCarriers(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CarriersApi = CarriersApi;
/**
 * DownloadsApi - axios parameter creator
 * @export
 */
const DownloadsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get File
         * @summary Download File
         * @param {string} subdir
         * @param {string} filename
         * @param {string} dir
         * @param {string} [download]
         * @param {number} [rotation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: (subdir, filename, dir, download, rotation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subdir' is not null or undefined
            (0, common_1.assertParamExists)('downloadFile', 'subdir', subdir);
            // verify required parameter 'filename' is not null or undefined
            (0, common_1.assertParamExists)('downloadFile', 'filename', filename);
            // verify required parameter 'dir' is not null or undefined
            (0, common_1.assertParamExists)('downloadFile', 'dir', dir);
            const localVarPath = `/v1/downloads/{dir}/{subdir}/{filename}`
                .replace(`{${"subdir"}}`, encodeURIComponent(String(subdir)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)))
                .replace(`{${"dir"}}`, encodeURIComponent(String(dir)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }
            if (rotation !== undefined) {
                localVarQueryParameter['rotation'] = rotation;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DownloadsApiAxiosParamCreator = DownloadsApiAxiosParamCreator;
/**
 * DownloadsApi - functional programming interface
 * @export
 */
const DownloadsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DownloadsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get File
         * @summary Download File
         * @param {string} subdir
         * @param {string} filename
         * @param {string} dir
         * @param {string} [download]
         * @param {number} [rotation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(subdir, filename, dir, download, rotation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadFile(subdir, filename, dir, download, rotation, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.DownloadsApiFp = DownloadsApiFp;
/**
 * DownloadsApi - factory interface
 * @export
 */
const DownloadsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DownloadsApiFp)(configuration);
    return {
        /**
         * Get File
         * @summary Download File
         * @param {string} subdir
         * @param {string} filename
         * @param {string} dir
         * @param {string} [download]
         * @param {number} [rotation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(subdir, filename, dir, download, rotation, options) {
            return localVarFp.downloadFile(subdir, filename, dir, download, rotation, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DownloadsApiFactory = DownloadsApiFactory;
/**
 * DownloadsApi - object-oriented interface
 * @export
 * @class DownloadsApi
 * @extends {BaseAPI}
 */
class DownloadsApi extends base_1.BaseAPI {
    /**
     * Get File
     * @summary Download File
     * @param {string} subdir
     * @param {string} filename
     * @param {string} dir
     * @param {string} [download]
     * @param {number} [rotation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadsApi
     */
    downloadFile(subdir, filename, dir, download, rotation, options) {
        return (0, exports.DownloadsApiFp)(this.configuration).downloadFile(subdir, filename, dir, download, rotation, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DownloadsApi = DownloadsApi;
/**
 * InsuranceApi - axios parameter creator
 * @export
 */
const InsuranceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
         * @summary Add Funds To Insurance
         * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToInsurance: (addFundsToInsuranceRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'addFundsToInsuranceRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('addFundsToInsurance', 'addFundsToInsuranceRequestBody', addFundsToInsuranceRequestBody);
            const localVarPath = `/v1/insurance/shipsurance/add_funds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addFundsToInsuranceRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Connect a Shipsurance Account
         * @summary Connect a Shipsurance Account
         * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectInsurer: (connectInsurerRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectInsurerRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('connectInsurer', 'connectInsurerRequestBody', connectInsurerRequestBody);
            const localVarPath = `/v1/connections/insurance/shipsurance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(connectInsurerRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Disconnect a Shipsurance Account
         * @summary Disconnect a Shipsurance Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectInsurer: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/connections/insurance/shipsurance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the balance of your Shipsurance account.
         * @summary Get Insurance Funds Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsuranceBalance: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/insurance/shipsurance/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InsuranceApiAxiosParamCreator = InsuranceApiAxiosParamCreator;
/**
 * InsuranceApi - functional programming interface
 * @export
 */
const InsuranceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InsuranceApiAxiosParamCreator)(configuration);
    return {
        /**
         * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
         * @summary Add Funds To Insurance
         * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToInsurance(addFundsToInsuranceRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addFundsToInsurance(addFundsToInsuranceRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Connect a Shipsurance Account
         * @summary Connect a Shipsurance Account
         * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectInsurer(connectInsurerRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.connectInsurer(connectInsurerRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Disconnect a Shipsurance Account
         * @summary Disconnect a Shipsurance Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectInsurer(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.disconnectInsurer(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve the balance of your Shipsurance account.
         * @summary Get Insurance Funds Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsuranceBalance(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInsuranceBalance(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InsuranceApiFp = InsuranceApiFp;
/**
 * InsuranceApi - factory interface
 * @export
 */
const InsuranceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InsuranceApiFp)(configuration);
    return {
        /**
         * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
         * @summary Add Funds To Insurance
         * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToInsurance(addFundsToInsuranceRequestBody, options) {
            return localVarFp.addFundsToInsurance(addFundsToInsuranceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect a Shipsurance Account
         * @summary Connect a Shipsurance Account
         * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectInsurer(connectInsurerRequestBody, options) {
            return localVarFp.connectInsurer(connectInsurerRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect a Shipsurance Account
         * @summary Disconnect a Shipsurance Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectInsurer(options) {
            return localVarFp.disconnectInsurer(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the balance of your Shipsurance account.
         * @summary Get Insurance Funds Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsuranceBalance(options) {
            return localVarFp.getInsuranceBalance(options).then((request) => request(axios, basePath));
        },
    };
};
exports.InsuranceApiFactory = InsuranceApiFactory;
/**
 * InsuranceApi - object-oriented interface
 * @export
 * @class InsuranceApi
 * @extends {BaseAPI}
 */
class InsuranceApi extends base_1.BaseAPI {
    /**
     * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
     * @summary Add Funds To Insurance
     * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    addFundsToInsurance(addFundsToInsuranceRequestBody, options) {
        return (0, exports.InsuranceApiFp)(this.configuration).addFundsToInsurance(addFundsToInsuranceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Connect a Shipsurance Account
     * @summary Connect a Shipsurance Account
     * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    connectInsurer(connectInsurerRequestBody, options) {
        return (0, exports.InsuranceApiFp)(this.configuration).connectInsurer(connectInsurerRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disconnect a Shipsurance Account
     * @summary Disconnect a Shipsurance Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    disconnectInsurer(options) {
        return (0, exports.InsuranceApiFp)(this.configuration).disconnectInsurer(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the balance of your Shipsurance account.
     * @summary Get Insurance Funds Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    getInsuranceBalance(options) {
        return (0, exports.InsuranceApiFp)(this.configuration).getInsuranceBalance(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InsuranceApi = InsuranceApi;
/**
 * LabelsApi - axios parameter creator
 * @export
 */
const LabelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {CreateLabelRequestBody} createLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel: (createLabelRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createLabelRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createLabel', 'createLabelRequestBody', createLabelRequestBody);
            const localVarPath = `/v1/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createLabelRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromRate: (rateId, createLabelFromRateRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'rateId' is not null or undefined
            (0, common_1.assertParamExists)('createLabelFromRate', 'rateId', rateId);
            // verify required parameter 'createLabelFromRateRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createLabelFromRate', 'createLabelFromRateRequestBody', createLabelFromRateRequestBody);
            const localVarPath = `/v1/labels/rates/{rate_id}`
                .replace(`{${"rate_id"}}`, encodeURIComponent(String(rateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createLabelFromRateRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info.
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromShipment: (shipmentId, createLabelFromShipmentRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('createLabelFromShipment', 'shipmentId', shipmentId);
            // verify required parameter 'createLabelFromShipmentRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createLabelFromShipment', 'createLabelFromShipmentRequestBody', createLabelFromShipmentRequestBody);
            const localVarPath = `/v1/labels/shipment/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createLabelFromShipmentRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel: (labelId, createReturnLabelRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelId' is not null or undefined
            (0, common_1.assertParamExists)('createReturnLabel', 'labelId', labelId);
            // verify required parameter 'createReturnLabelRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createReturnLabel', 'createReturnLabelRequestBody', createReturnLabelRequestBody);
            const localVarPath = `/v1/labels/{label_id}/return`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createReturnLabelRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Find a label by using the external shipment id that was used during label creation
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelByExternalShipmentId: (externalShipmentId, labelDownloadType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'externalShipmentId' is not null or undefined
            (0, common_1.assertParamExists)('getLabelByExternalShipmentId', 'externalShipmentId', externalShipmentId);
            const localVarPath = `/v1/labels/external_shipment_id/{external_shipment_id}`
                .replace(`{${"external_shipment_id"}}`, encodeURIComponent(String(externalShipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (labelDownloadType !== undefined) {
                localVarQueryParameter['label_download_type'] = labelDownloadType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById: (labelId, labelDownloadType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelId' is not null or undefined
            (0, common_1.assertParamExists)('getLabelById', 'labelId', labelId);
            const localVarPath = `/v1/labels/{label_id}`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (labelDownloadType !== undefined) {
                localVarQueryParameter['label_download_type'] = labelDownloadType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLogFromLabel: (labelId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelId' is not null or undefined
            (0, common_1.assertParamExists)('getTrackingLogFromLabel', 'labelId', labelId);
            const localVarPath = `/v1/labels/{label_id}/track`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels: (labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (labelStatus !== undefined) {
                localVarQueryParameter['label_status'] = labelStatus;
            }
            if (serviceCode !== undefined) {
                localVarQueryParameter['service_code'] = serviceCode;
            }
            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }
            if (rateId !== undefined) {
                localVarQueryParameter['rate_id'] = rateId;
            }
            if (shipmentId !== undefined) {
                localVarQueryParameter['shipment_id'] = shipmentId;
            }
            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: (labelId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'labelId' is not null or undefined
            (0, common_1.assertParamExists)('voidLabel', 'labelId', labelId);
            const localVarPath = `/v1/labels/{label_id}/void`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LabelsApiAxiosParamCreator = LabelsApiAxiosParamCreator;
/**
 * LabelsApi - functional programming interface
 * @export
 */
const LabelsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LabelsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {CreateLabelRequestBody} createLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel(createLabelRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLabel(createLabelRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromRate(rateId, createLabelFromRateRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLabelFromRate(rateId, createLabelFromRateRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info.
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel(labelId, createReturnLabelRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createReturnLabel(labelId, createReturnLabelRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Find a label by using the external shipment id that was used during label creation
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById(labelId, labelDownloadType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLabelById(labelId, labelDownloadType, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLogFromLabel(labelId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrackingLogFromLabel(labelId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(labelId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.voidLabel(labelId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.LabelsApiFp = LabelsApiFp;
/**
 * LabelsApi - factory interface
 * @export
 */
const LabelsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LabelsApiFp)(configuration);
    return {
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {CreateLabelRequestBody} createLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel(createLabelRequestBody, options) {
            return localVarFp.createLabel(createLabelRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromRate(rateId, createLabelFromRateRequestBody, options) {
            return localVarFp.createLabelFromRate(rateId, createLabelFromRateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info.
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options) {
            return localVarFp.createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel(labelId, createReturnLabelRequestBody, options) {
            return localVarFp.createReturnLabel(labelId, createReturnLabelRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a label by using the external shipment id that was used during label creation
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options) {
            return localVarFp.getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById(labelId, labelDownloadType, options) {
            return localVarFp.getLabelById(labelId, labelDownloadType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLogFromLabel(labelId, options) {
            return localVarFp.getTrackingLogFromLabel(labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options) {
            return localVarFp.listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(labelId, options) {
            return localVarFp.voidLabel(labelId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LabelsApiFactory = LabelsApiFactory;
/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
class LabelsApi extends base_1.BaseAPI {
    /**
     * Purchase and print a label for shipment
     * @summary Purchase Label
     * @param {CreateLabelRequestBody} createLabelRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createLabel(createLabelRequestBody, options) {
        return (0, exports.LabelsApiFp)(this.configuration).createLabel(createLabelRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
     * @summary Purchase Label with Rate ID
     * @param {string} rateId Rate ID
     * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createLabelFromRate(rateId, createLabelFromRateRequestBody, options) {
        return (0, exports.LabelsApiFp)(this.configuration).createLabelFromRate(rateId, createLabelFromRateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Purchase a label using a shipment ID that has already been created with the desired address and package info.
     * @summary Purchase Label with Shipment ID
     * @param {string} shipmentId Shipment ID
     * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options) {
        return (0, exports.LabelsApiFp)(this.configuration).createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a return label
     * @summary Create a return label
     * @param {string} labelId Label ID
     * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createReturnLabel(labelId, createReturnLabelRequestBody, options) {
        return (0, exports.LabelsApiFp)(this.configuration).createReturnLabel(labelId, createReturnLabelRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Find a label by using the external shipment id that was used during label creation
     * @summary Get Label By External Shipment ID
     * @param {string} externalShipmentId
     * @param {LabelDownloadType} [labelDownloadType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options) {
        return (0, exports.LabelsApiFp)(this.configuration).getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve information for individual labels.
     * @summary Get Label By ID
     * @param {string} labelId Label ID
     * @param {LabelDownloadType} [labelDownloadType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getLabelById(labelId, labelDownloadType, options) {
        return (0, exports.LabelsApiFp)(this.configuration).getLabelById(labelId, labelDownloadType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the label\'s tracking information
     * @summary Get Label Tracking Information
     * @param {string} labelId Label ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getTrackingLogFromLabel(labelId, options) {
        return (0, exports.LabelsApiFp)(this.configuration).getTrackingLogFromLabel(labelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
     * @summary List labels
     * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
     * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
     * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
     * @param {string} [trackingNumber] Only return labels with a specific tracking number
     * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
     * @param {string} [rateId] Rate ID
     * @param {string} [shipmentId] Shipment ID
     * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
     * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
     * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options) {
        return (0, exports.LabelsApiFp)(this.configuration).listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Void a label by ID to get a refund.
     * @summary Void a Label By ID
     * @param {string} labelId Label ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    voidLabel(labelId, options) {
        return (0, exports.LabelsApiFp)(this.configuration).voidLabel(labelId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LabelsApi = LabelsApi;
/**
 * @export
 */
exports.ListLabelsSortByEnum = {
    ModifiedAt: 'modified_at',
    CreatedAt: 'created_at'
};
/**
 * ManifestsApi - axios parameter creator
 * @export
 */
const ManifestsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
         * @summary Create Manifest
         * @param {CreateManifestRequestBody} createManifestRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManifest: (createManifestRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createManifestRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createManifest', 'createManifestRequestBody', createManifestRequestBody);
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createManifestRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Manifest By Id
         * @summary Get Manifest By Id
         * @param {string} manifestId The Manifest Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestById: (manifestId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'manifestId' is not null or undefined
            (0, common_1.assertParamExists)('getManifestById', 'manifestId', manifestId);
            const localVarPath = `/v1/manifests/{manifest_id}`
                .replace(`{${"manifest_id"}}`, encodeURIComponent(String(manifestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Manifest Request By Id
         * @summary Get Manifest Request By Id
         * @param {string} manifestRequestId The Manifest Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestRequestById: (manifestRequestId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'manifestRequestId' is not null or undefined
            (0, common_1.assertParamExists)('getManifestRequestById', 'manifestRequestId', manifestRequestId);
            const localVarPath = `/v1/manifests/requests/{manifest_request_id}`
                .replace(`{${"manifest_request_id"}}`, encodeURIComponent(String(manifestRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
         * @summary List Manifests
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [shipDateStart] ship date start range
         * @param {string} [shipDateEnd] ship date end range
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [carrierId] Carrier ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {Array<string>} [labelIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManifests: (warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }
            if (shipDateStart !== undefined) {
                localVarQueryParameter['ship_date_start'] = (shipDateStart instanceof Date) ?
                    shipDateStart.toISOString() :
                    shipDateStart;
            }
            if (shipDateEnd !== undefined) {
                localVarQueryParameter['ship_date_end'] = (shipDateEnd instanceof Date) ?
                    shipDateEnd.toISOString() :
                    shipDateEnd;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (labelIds) {
                localVarQueryParameter['label_ids'] = labelIds;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ManifestsApiAxiosParamCreator = ManifestsApiAxiosParamCreator;
/**
 * ManifestsApi - functional programming interface
 * @export
 */
const ManifestsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ManifestsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
         * @summary Create Manifest
         * @param {CreateManifestRequestBody} createManifestRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManifest(createManifestRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createManifest(createManifestRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Manifest By Id
         * @summary Get Manifest By Id
         * @param {string} manifestId The Manifest Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestById(manifestId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getManifestById(manifestId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Manifest Request By Id
         * @summary Get Manifest Request By Id
         * @param {string} manifestRequestId The Manifest Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestRequestById(manifestRequestId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getManifestRequestById(manifestRequestId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
         * @summary List Manifests
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [shipDateStart] ship date start range
         * @param {string} [shipDateEnd] ship date end range
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [carrierId] Carrier ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {Array<string>} [labelIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ManifestsApiFp = ManifestsApiFp;
/**
 * ManifestsApi - factory interface
 * @export
 */
const ManifestsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ManifestsApiFp)(configuration);
    return {
        /**
         * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
         * @summary Create Manifest
         * @param {CreateManifestRequestBody} createManifestRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManifest(createManifestRequestBody, options) {
            return localVarFp.createManifest(createManifestRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Manifest By Id
         * @summary Get Manifest By Id
         * @param {string} manifestId The Manifest Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestById(manifestId, options) {
            return localVarFp.getManifestById(manifestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Manifest Request By Id
         * @summary Get Manifest Request By Id
         * @param {string} manifestRequestId The Manifest Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestRequestById(manifestRequestId, options) {
            return localVarFp.getManifestRequestById(manifestRequestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
         * @summary List Manifests
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [shipDateStart] ship date start range
         * @param {string} [shipDateEnd] ship date end range
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [carrierId] Carrier ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {Array<string>} [labelIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options) {
            return localVarFp.listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ManifestsApiFactory = ManifestsApiFactory;
/**
 * ManifestsApi - object-oriented interface
 * @export
 * @class ManifestsApi
 * @extends {BaseAPI}
 */
class ManifestsApi extends base_1.BaseAPI {
    /**
     * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
     * @summary Create Manifest
     * @param {CreateManifestRequestBody} createManifestRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    createManifest(createManifestRequestBody, options) {
        return (0, exports.ManifestsApiFp)(this.configuration).createManifest(createManifestRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Manifest By Id
     * @summary Get Manifest By Id
     * @param {string} manifestId The Manifest Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    getManifestById(manifestId, options) {
        return (0, exports.ManifestsApiFp)(this.configuration).getManifestById(manifestId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Manifest Request By Id
     * @summary Get Manifest Request By Id
     * @param {string} manifestRequestId The Manifest Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    getManifestRequestById(manifestRequestId, options) {
        return (0, exports.ManifestsApiFp)(this.configuration).getManifestRequestById(manifestRequestId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
     * @summary List Manifests
     * @param {string} [warehouseId] Warehouse ID
     * @param {string} [shipDateStart] ship date start range
     * @param {string} [shipDateEnd] ship date end range
     * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
     * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
     * @param {string} [carrierId] Carrier ID
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {Array<string>} [labelIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options) {
        return (0, exports.ManifestsApiFp)(this.configuration).listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ManifestsApi = ManifestsApi;
/**
 * PackagePickupsApi - axios parameter creator
 * @export
 */
const PackagePickupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a previously-scheduled pickup by ID
         * @summary Delete a Scheduled Pickup
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledPickup: (pickupId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pickupId' is not null or undefined
            (0, common_1.assertParamExists)('deleteScheduledPickup', 'pickupId', pickupId);
            const localVarPath = `/v1/pickups/{pickup_id}`
                .replace(`{${"pickup_id"}}`, encodeURIComponent(String(pickupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Pickup By ID
         * @summary Get Pickup By ID
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickupById: (pickupId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pickupId' is not null or undefined
            (0, common_1.assertParamExists)('getPickupById', 'pickupId', pickupId);
            const localVarPath = `/v1/pickups/{pickup_id}`
                .replace(`{${"pickup_id"}}`, encodeURIComponent(String(pickupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all pickups that have been scheduled for this carrier
         * @summary List Scheduled Pickups
         * @param {string} [carrierId] Carrier ID
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPickups: (carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }
            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Schedule a package pickup with a carrier
         * @summary Schedule a Pickup
         * @param {SchedulePickupRequestBody} schedulePickupRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: (schedulePickupRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'schedulePickupRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('schedulePickup', 'schedulePickupRequestBody', schedulePickupRequestBody);
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schedulePickupRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PackagePickupsApiAxiosParamCreator = PackagePickupsApiAxiosParamCreator;
/**
 * PackagePickupsApi - functional programming interface
 * @export
 */
const PackagePickupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PackagePickupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a previously-scheduled pickup by ID
         * @summary Delete a Scheduled Pickup
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledPickup(pickupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteScheduledPickup(pickupId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Pickup By ID
         * @summary Get Pickup By ID
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickupById(pickupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPickupById(pickupId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List all pickups that have been scheduled for this carrier
         * @summary List Scheduled Pickups
         * @param {string} [carrierId] Carrier ID
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Schedule a package pickup with a carrier
         * @summary Schedule a Pickup
         * @param {SchedulePickupRequestBody} schedulePickupRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(schedulePickupRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.schedulePickup(schedulePickupRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PackagePickupsApiFp = PackagePickupsApiFp;
/**
 * PackagePickupsApi - factory interface
 * @export
 */
const PackagePickupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PackagePickupsApiFp)(configuration);
    return {
        /**
         * Delete a previously-scheduled pickup by ID
         * @summary Delete a Scheduled Pickup
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledPickup(pickupId, options) {
            return localVarFp.deleteScheduledPickup(pickupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Pickup By ID
         * @summary Get Pickup By ID
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickupById(pickupId, options) {
            return localVarFp.getPickupById(pickupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all pickups that have been scheduled for this carrier
         * @summary List Scheduled Pickups
         * @param {string} [carrierId] Carrier ID
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options) {
            return localVarFp.listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a package pickup with a carrier
         * @summary Schedule a Pickup
         * @param {SchedulePickupRequestBody} schedulePickupRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(schedulePickupRequestBody, options) {
            return localVarFp.schedulePickup(schedulePickupRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PackagePickupsApiFactory = PackagePickupsApiFactory;
/**
 * PackagePickupsApi - object-oriented interface
 * @export
 * @class PackagePickupsApi
 * @extends {BaseAPI}
 */
class PackagePickupsApi extends base_1.BaseAPI {
    /**
     * Delete a previously-scheduled pickup by ID
     * @summary Delete a Scheduled Pickup
     * @param {string} pickupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    deleteScheduledPickup(pickupId, options) {
        return (0, exports.PackagePickupsApiFp)(this.configuration).deleteScheduledPickup(pickupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Pickup By ID
     * @summary Get Pickup By ID
     * @param {string} pickupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    getPickupById(pickupId, options) {
        return (0, exports.PackagePickupsApiFp)(this.configuration).getPickupById(pickupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all pickups that have been scheduled for this carrier
     * @summary List Scheduled Pickups
     * @param {string} [carrierId] Carrier ID
     * @param {string} [warehouseId] Warehouse ID
     * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
     * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options) {
        return (0, exports.PackagePickupsApiFp)(this.configuration).listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Schedule a package pickup with a carrier
     * @summary Schedule a Pickup
     * @param {SchedulePickupRequestBody} schedulePickupRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    schedulePickup(schedulePickupRequestBody, options) {
        return (0, exports.PackagePickupsApiFp)(this.configuration).schedulePickup(schedulePickupRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PackagePickupsApi = PackagePickupsApi;
/**
 * PackageTypesApi - axios parameter creator
 * @export
 */
const PackageTypesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a custom package type to better assist in getting accurate rate estimates
         * @summary Create Custom Package Type
         * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageType: (createPackageTypeRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createPackageTypeRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createPackageType', 'createPackageTypeRequestBody', createPackageTypeRequestBody);
            const localVarPath = `/v1/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPackageTypeRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a custom package using the ID
         * @summary Delete A Custom Package By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageType: (packageId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'packageId' is not null or undefined
            (0, common_1.assertParamExists)('deletePackageType', 'packageId', packageId);
            const localVarPath = `/v1/packages/{package_id}`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Custom Package Type by ID
         * @summary Get Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageTypeById: (packageId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'packageId' is not null or undefined
            (0, common_1.assertParamExists)('getPackageTypeById', 'packageId', packageId);
            const localVarPath = `/v1/packages/{package_id}`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the custom package types associated with the account
         * @summary List Custom Package Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageTypes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the custom package type object by ID
         * @summary Update Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageType: (packageId, updatePackageTypeRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'packageId' is not null or undefined
            (0, common_1.assertParamExists)('updatePackageType', 'packageId', packageId);
            // verify required parameter 'updatePackageTypeRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updatePackageType', 'updatePackageTypeRequestBody', updatePackageTypeRequestBody);
            const localVarPath = `/v1/packages/{package_id}`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updatePackageTypeRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PackageTypesApiAxiosParamCreator = PackageTypesApiAxiosParamCreator;
/**
 * PackageTypesApi - functional programming interface
 * @export
 */
const PackageTypesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PackageTypesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a custom package type to better assist in getting accurate rate estimates
         * @summary Create Custom Package Type
         * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageType(createPackageTypeRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPackageType(createPackageTypeRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete a custom package using the ID
         * @summary Delete A Custom Package By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageType(packageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePackageType(packageId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Custom Package Type by ID
         * @summary Get Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageTypeById(packageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPackageTypeById(packageId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List the custom package types associated with the account
         * @summary List Custom Package Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageTypes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPackageTypes(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update the custom package type object by ID
         * @summary Update Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageType(packageId, updatePackageTypeRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePackageType(packageId, updatePackageTypeRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PackageTypesApiFp = PackageTypesApiFp;
/**
 * PackageTypesApi - factory interface
 * @export
 */
const PackageTypesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PackageTypesApiFp)(configuration);
    return {
        /**
         * Create a custom package type to better assist in getting accurate rate estimates
         * @summary Create Custom Package Type
         * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageType(createPackageTypeRequestBody, options) {
            return localVarFp.createPackageType(createPackageTypeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom package using the ID
         * @summary Delete A Custom Package By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageType(packageId, options) {
            return localVarFp.deletePackageType(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Custom Package Type by ID
         * @summary Get Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageTypeById(packageId, options) {
            return localVarFp.getPackageTypeById(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the custom package types associated with the account
         * @summary List Custom Package Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageTypes(options) {
            return localVarFp.listPackageTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the custom package type object by ID
         * @summary Update Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageType(packageId, updatePackageTypeRequestBody, options) {
            return localVarFp.updatePackageType(packageId, updatePackageTypeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PackageTypesApiFactory = PackageTypesApiFactory;
/**
 * PackageTypesApi - object-oriented interface
 * @export
 * @class PackageTypesApi
 * @extends {BaseAPI}
 */
class PackageTypesApi extends base_1.BaseAPI {
    /**
     * Create a custom package type to better assist in getting accurate rate estimates
     * @summary Create Custom Package Type
     * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    createPackageType(createPackageTypeRequestBody, options) {
        return (0, exports.PackageTypesApiFp)(this.configuration).createPackageType(createPackageTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a custom package using the ID
     * @summary Delete A Custom Package By ID
     * @param {string} packageId Package ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    deletePackageType(packageId, options) {
        return (0, exports.PackageTypesApiFp)(this.configuration).deletePackageType(packageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Custom Package Type by ID
     * @summary Get Custom Package Type By ID
     * @param {string} packageId Package ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    getPackageTypeById(packageId, options) {
        return (0, exports.PackageTypesApiFp)(this.configuration).getPackageTypeById(packageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the custom package types associated with the account
     * @summary List Custom Package Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    listPackageTypes(options) {
        return (0, exports.PackageTypesApiFp)(this.configuration).listPackageTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the custom package type object by ID
     * @summary Update Custom Package Type By ID
     * @param {string} packageId Package ID
     * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    updatePackageType(packageId, updatePackageTypeRequestBody, options) {
        return (0, exports.PackageTypesApiFp)(this.configuration).updatePackageType(packageId, updatePackageTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PackageTypesApi = PackageTypesApi;
/**
 * RatesApi - axios parameter creator
 * @export
 */
const RatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
         * @summary Get Shipping Rates
         * @param {CalculateRatesRequestBody} calculateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRates: (calculateRatesRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'calculateRatesRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('calculateRates', 'calculateRatesRequestBody', calculateRatesRequestBody);
            const localVarPath = `/v1/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(calculateRatesRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Bulk Shipment Rates
         * @summary Get Bulk Rates
         * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareBulkRates: (compareBulkRatesRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'compareBulkRatesRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('compareBulkRates', 'compareBulkRatesRequestBody', compareBulkRatesRequestBody);
            const localVarPath = `/v1/rates/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(compareBulkRatesRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Rate Estimates
         * @summary Estimate Rates
         * @param {EstimateRatesRequestBody} estimateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRates: (estimateRatesRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'estimateRatesRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('estimateRates', 'estimateRatesRequestBody', estimateRatesRequestBody);
            const localVarPath = `/v1/rates/estimate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(estimateRatesRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a previously queried rate by its ID
         * @summary Get Rate By ID
         * @param {string} rateId Rate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateById: (rateId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'rateId' is not null or undefined
            (0, common_1.assertParamExists)('getRateById', 'rateId', rateId);
            const localVarPath = `/v1/rates/{rate_id}`
                .replace(`{${"rate_id"}}`, encodeURIComponent(String(rateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RatesApiAxiosParamCreator = RatesApiAxiosParamCreator;
/**
 * RatesApi - functional programming interface
 * @export
 */
const RatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RatesApiAxiosParamCreator)(configuration);
    return {
        /**
         * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
         * @summary Get Shipping Rates
         * @param {CalculateRatesRequestBody} calculateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRates(calculateRatesRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.calculateRates(calculateRatesRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Bulk Shipment Rates
         * @summary Get Bulk Rates
         * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareBulkRates(compareBulkRatesRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.compareBulkRates(compareBulkRatesRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Rate Estimates
         * @summary Estimate Rates
         * @param {EstimateRatesRequestBody} estimateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRates(estimateRatesRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.estimateRates(estimateRatesRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve a previously queried rate by its ID
         * @summary Get Rate By ID
         * @param {string} rateId Rate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateById(rateId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRateById(rateId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.RatesApiFp = RatesApiFp;
/**
 * RatesApi - factory interface
 * @export
 */
const RatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RatesApiFp)(configuration);
    return {
        /**
         * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
         * @summary Get Shipping Rates
         * @param {CalculateRatesRequestBody} calculateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRates(calculateRatesRequestBody, options) {
            return localVarFp.calculateRates(calculateRatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Bulk Shipment Rates
         * @summary Get Bulk Rates
         * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareBulkRates(compareBulkRatesRequestBody, options) {
            return localVarFp.compareBulkRates(compareBulkRatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Rate Estimates
         * @summary Estimate Rates
         * @param {EstimateRatesRequestBody} estimateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRates(estimateRatesRequestBody, options) {
            return localVarFp.estimateRates(estimateRatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a previously queried rate by its ID
         * @summary Get Rate By ID
         * @param {string} rateId Rate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateById(rateId, options) {
            return localVarFp.getRateById(rateId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RatesApiFactory = RatesApiFactory;
/**
 * RatesApi - object-oriented interface
 * @export
 * @class RatesApi
 * @extends {BaseAPI}
 */
class RatesApi extends base_1.BaseAPI {
    /**
     * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
     * @summary Get Shipping Rates
     * @param {CalculateRatesRequestBody} calculateRatesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    calculateRates(calculateRatesRequestBody, options) {
        return (0, exports.RatesApiFp)(this.configuration).calculateRates(calculateRatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Bulk Shipment Rates
     * @summary Get Bulk Rates
     * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    compareBulkRates(compareBulkRatesRequestBody, options) {
        return (0, exports.RatesApiFp)(this.configuration).compareBulkRates(compareBulkRatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Rate Estimates
     * @summary Estimate Rates
     * @param {EstimateRatesRequestBody} estimateRatesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    estimateRates(estimateRatesRequestBody, options) {
        return (0, exports.RatesApiFp)(this.configuration).estimateRates(estimateRatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a previously queried rate by its ID
     * @summary Get Rate By ID
     * @param {string} rateId Rate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    getRateById(rateId, options) {
        return (0, exports.RatesApiFp)(this.configuration).getRateById(rateId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RatesApi = RatesApi;
/**
 * ServicePointsApi - axios parameter creator
 * @export
 */
const ServicePointsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a carrier service point by using the service_point_id
         * @summary Get Service Point By ID
         * @param {string} carrierCode Carrier code
         * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
         * @param {string} servicePointId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsGetById: (carrierCode, countryCode, servicePointId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'carrierCode' is not null or undefined
            (0, common_1.assertParamExists)('servicePointsGetById', 'carrierCode', carrierCode);
            // verify required parameter 'countryCode' is not null or undefined
            (0, common_1.assertParamExists)('servicePointsGetById', 'countryCode', countryCode);
            // verify required parameter 'servicePointId' is not null or undefined
            (0, common_1.assertParamExists)('servicePointsGetById', 'servicePointId', servicePointId);
            const localVarPath = `/v1/service_points/{carrier_code}/{country_code}/{service_point_id}`
                .replace(`{${"carrier_code"}}`, encodeURIComponent(String(carrierCode)))
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)))
                .replace(`{${"service_point_id"}}`, encodeURIComponent(String(servicePointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List carrier service points by location
         * @summary List Service Points
         * @param {GetServicePointsRequest} getServicePointsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsList: (getServicePointsRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'getServicePointsRequest' is not null or undefined
            (0, common_1.assertParamExists)('servicePointsList', 'getServicePointsRequest', getServicePointsRequest);
            const localVarPath = `/v1/service_points/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(getServicePointsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ServicePointsApiAxiosParamCreator = ServicePointsApiAxiosParamCreator;
/**
 * ServicePointsApi - functional programming interface
 * @export
 */
const ServicePointsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ServicePointsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a carrier service point by using the service_point_id
         * @summary Get Service Point By ID
         * @param {string} carrierCode Carrier code
         * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
         * @param {string} servicePointId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsGetById(carrierCode, countryCode, servicePointId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.servicePointsGetById(carrierCode, countryCode, servicePointId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List carrier service points by location
         * @summary List Service Points
         * @param {GetServicePointsRequest} getServicePointsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsList(getServicePointsRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.servicePointsList(getServicePointsRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ServicePointsApiFp = ServicePointsApiFp;
/**
 * ServicePointsApi - factory interface
 * @export
 */
const ServicePointsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ServicePointsApiFp)(configuration);
    return {
        /**
         * Returns a carrier service point by using the service_point_id
         * @summary Get Service Point By ID
         * @param {string} carrierCode Carrier code
         * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
         * @param {string} servicePointId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsGetById(carrierCode, countryCode, servicePointId, options) {
            return localVarFp.servicePointsGetById(carrierCode, countryCode, servicePointId, options).then((request) => request(axios, basePath));
        },
        /**
         * List carrier service points by location
         * @summary List Service Points
         * @param {GetServicePointsRequest} getServicePointsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsList(getServicePointsRequest, options) {
            return localVarFp.servicePointsList(getServicePointsRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ServicePointsApiFactory = ServicePointsApiFactory;
/**
 * ServicePointsApi - object-oriented interface
 * @export
 * @class ServicePointsApi
 * @extends {BaseAPI}
 */
class ServicePointsApi extends base_1.BaseAPI {
    /**
     * Returns a carrier service point by using the service_point_id
     * @summary Get Service Point By ID
     * @param {string} carrierCode Carrier code
     * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
     * @param {string} servicePointId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointsApi
     */
    servicePointsGetById(carrierCode, countryCode, servicePointId, options) {
        return (0, exports.ServicePointsApiFp)(this.configuration).servicePointsGetById(carrierCode, countryCode, servicePointId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List carrier service points by location
     * @summary List Service Points
     * @param {GetServicePointsRequest} getServicePointsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointsApi
     */
    servicePointsList(getServicePointsRequest, options) {
        return (0, exports.ServicePointsApiFp)(this.configuration).servicePointsList(getServicePointsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ServicePointsApi = ServicePointsApi;
/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
const ShipmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
         * @summary Cancel a Shipment
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipments: (shipmentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('cancelShipments', 'shipmentId', shipmentId);
            const localVarPath = `/v1/shipments/{shipment_id}/cancel`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create one or multiple shipments.
         * @summary Create Shipments
         * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments: (createShipmentsRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createShipmentsRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createShipments', 'createShipmentsRequestBody', createShipmentsRequestBody);
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createShipmentsRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Query Shipments created using your own custom ID convention using this endpint
         * @summary Get Shipment By External ID
         * @param {string} externalShipmentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentByExternalId: (externalShipmentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'externalShipmentId' is not null or undefined
            (0, common_1.assertParamExists)('getShipmentByExternalId', 'externalShipmentId', externalShipmentId);
            const localVarPath = `/v1/shipments/external_shipment_id/{external_shipment_id}`
                .replace(`{${"external_shipment_id"}}`, encodeURIComponent(String(externalShipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get an individual shipment based on its ID
         * @summary Get Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentById: (shipmentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('getShipmentById', 'shipmentId', shipmentId);
            const localVarPath = `/v1/shipments/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Rates for the shipment information associated with the shipment ID
         * @summary Get Shipment Rates
         * @param {string} shipmentId Shipment ID
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipmentRates: (shipmentId, createdAtStart, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('listShipmentRates', 'shipmentId', shipmentId);
            const localVarPath = `/v1/shipments/{shipment_id}/rates`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get list of Shipments
         * @summary List Shipments
         * @param {ShipmentStatus} [shipmentStatus]
         * @param {string} [batchId] Batch ID
         * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
         * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {string} [salesOrderId] Sales Order ID
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ShipmentsSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipments: (shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (shipmentStatus !== undefined) {
                localVarQueryParameter['shipment_status'] = shipmentStatus;
            }
            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }
            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (modifiedAtStart !== undefined) {
                localVarQueryParameter['modified_at_start'] = (modifiedAtStart instanceof Date) ?
                    modifiedAtStart.toISOString() :
                    modifiedAtStart;
            }
            if (modifiedAtEnd !== undefined) {
                localVarQueryParameter['modified_at_end'] = (modifiedAtEnd instanceof Date) ?
                    modifiedAtEnd.toISOString() :
                    modifiedAtEnd;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (salesOrderId !== undefined) {
                localVarQueryParameter['sales_order_id'] = salesOrderId;
            }
            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse shipping info
         * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseShipment: (parseShipmentRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'parseShipmentRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('parseShipment', 'parseShipmentRequestBody', parseShipmentRequestBody);
            const localVarPath = `/v1/shipments/recognize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(parseShipmentRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a tag to the shipment object
         * @summary Add Tag to Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShipment: (shipmentId, tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('tagShipment', 'shipmentId', shipmentId);
            // verify required parameter 'tagName' is not null or undefined
            (0, common_1.assertParamExists)('tagShipment', 'tagName', tagName);
            const localVarPath = `/v1/shipments/{shipment_id}/tags/{tag_name}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Remove an existing tag from the Shipment object
         * @summary Remove Tag from Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagShipment: (shipmentId, tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('untagShipment', 'shipmentId', shipmentId);
            // verify required parameter 'tagName' is not null or undefined
            (0, common_1.assertParamExists)('untagShipment', 'tagName', tagName);
            const localVarPath = `/v1/shipments/{shipment_id}/tags/{tag_name}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a shipment object based on its ID
         * @summary Update Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipment: (shipmentId, updateShipmentRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shipmentId' is not null or undefined
            (0, common_1.assertParamExists)('updateShipment', 'shipmentId', shipmentId);
            // verify required parameter 'updateShipmentRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updateShipment', 'updateShipmentRequestBody', updateShipmentRequestBody);
            const localVarPath = `/v1/shipments/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateShipmentRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ShipmentsApiAxiosParamCreator = ShipmentsApiAxiosParamCreator;
/**
 * ShipmentsApi - functional programming interface
 * @export
 */
const ShipmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ShipmentsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
         * @summary Cancel a Shipment
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipments(shipmentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelShipments(shipmentId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create one or multiple shipments.
         * @summary Create Shipments
         * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments(createShipmentsRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createShipments(createShipmentsRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Query Shipments created using your own custom ID convention using this endpint
         * @summary Get Shipment By External ID
         * @param {string} externalShipmentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentByExternalId(externalShipmentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getShipmentByExternalId(externalShipmentId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get an individual shipment based on its ID
         * @summary Get Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentById(shipmentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getShipmentById(shipmentId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Rates for the shipment information associated with the shipment ID
         * @summary Get Shipment Rates
         * @param {string} shipmentId Shipment ID
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipmentRates(shipmentId, createdAtStart, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listShipmentRates(shipmentId, createdAtStart, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get list of Shipments
         * @summary List Shipments
         * @param {ShipmentStatus} [shipmentStatus]
         * @param {string} [batchId] Batch ID
         * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
         * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {string} [salesOrderId] Sales Order ID
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ShipmentsSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse shipping info
         * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseShipment(parseShipmentRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.parseShipment(parseShipmentRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a tag to the shipment object
         * @summary Add Tag to Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShipment(shipmentId, tagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tagShipment(shipmentId, tagName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Remove an existing tag from the Shipment object
         * @summary Remove Tag from Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagShipment(shipmentId, tagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.untagShipment(shipmentId, tagName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update a shipment object based on its ID
         * @summary Update Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipment(shipmentId, updateShipmentRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateShipment(shipmentId, updateShipmentRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ShipmentsApiFp = ShipmentsApiFp;
/**
 * ShipmentsApi - factory interface
 * @export
 */
const ShipmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ShipmentsApiFp)(configuration);
    return {
        /**
         * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
         * @summary Cancel a Shipment
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipments(shipmentId, options) {
            return localVarFp.cancelShipments(shipmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create one or multiple shipments.
         * @summary Create Shipments
         * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments(createShipmentsRequestBody, options) {
            return localVarFp.createShipments(createShipmentsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Shipments created using your own custom ID convention using this endpint
         * @summary Get Shipment By External ID
         * @param {string} externalShipmentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentByExternalId(externalShipmentId, options) {
            return localVarFp.getShipmentByExternalId(externalShipmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual shipment based on its ID
         * @summary Get Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentById(shipmentId, options) {
            return localVarFp.getShipmentById(shipmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Rates for the shipment information associated with the shipment ID
         * @summary Get Shipment Rates
         * @param {string} shipmentId Shipment ID
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipmentRates(shipmentId, createdAtStart, options) {
            return localVarFp.listShipmentRates(shipmentId, createdAtStart, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of Shipments
         * @summary List Shipments
         * @param {ShipmentStatus} [shipmentStatus]
         * @param {string} [batchId] Batch ID
         * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
         * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {string} [salesOrderId] Sales Order ID
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ShipmentsSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options) {
            return localVarFp.listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse shipping info
         * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseShipment(parseShipmentRequestBody, options) {
            return localVarFp.parseShipment(parseShipmentRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to the shipment object
         * @summary Add Tag to Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShipment(shipmentId, tagName, options) {
            return localVarFp.tagShipment(shipmentId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an existing tag from the Shipment object
         * @summary Remove Tag from Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagShipment(shipmentId, tagName, options) {
            return localVarFp.untagShipment(shipmentId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a shipment object based on its ID
         * @summary Update Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipment(shipmentId, updateShipmentRequestBody, options) {
            return localVarFp.updateShipment(shipmentId, updateShipmentRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ShipmentsApiFactory = ShipmentsApiFactory;
/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
class ShipmentsApi extends base_1.BaseAPI {
    /**
     * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
     * @summary Cancel a Shipment
     * @param {string} shipmentId Shipment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    cancelShipments(shipmentId, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).cancelShipments(shipmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create one or multiple shipments.
     * @summary Create Shipments
     * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    createShipments(createShipmentsRequestBody, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).createShipments(createShipmentsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query Shipments created using your own custom ID convention using this endpint
     * @summary Get Shipment By External ID
     * @param {string} externalShipmentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    getShipmentByExternalId(externalShipmentId, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).getShipmentByExternalId(externalShipmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an individual shipment based on its ID
     * @summary Get Shipment By ID
     * @param {string} shipmentId Shipment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    getShipmentById(shipmentId, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).getShipmentById(shipmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Rates for the shipment information associated with the shipment ID
     * @summary Get Shipment Rates
     * @param {string} shipmentId Shipment ID
     * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    listShipmentRates(shipmentId, createdAtStart, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).listShipmentRates(shipmentId, createdAtStart, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get list of Shipments
     * @summary List Shipments
     * @param {ShipmentStatus} [shipmentStatus]
     * @param {string} [batchId] Batch ID
     * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
     * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
     * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
     * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
     * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {string} [salesOrderId] Sales Order ID
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {ShipmentsSortBy} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
     * @summary Parse shipping info
     * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    parseShipment(parseShipmentRequestBody, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).parseShipment(parseShipmentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a tag to the shipment object
     * @summary Add Tag to Shipment
     * @param {string} shipmentId Shipment ID
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    tagShipment(shipmentId, tagName, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).tagShipment(shipmentId, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove an existing tag from the Shipment object
     * @summary Remove Tag from Shipment
     * @param {string} shipmentId Shipment ID
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    untagShipment(shipmentId, tagName, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).untagShipment(shipmentId, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a shipment object based on its ID
     * @summary Update Shipment By ID
     * @param {string} shipmentId Shipment ID
     * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    updateShipment(shipmentId, updateShipmentRequestBody, options) {
        return (0, exports.ShipmentsApiFp)(this.configuration).updateShipment(shipmentId, updateShipmentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ShipmentsApi = ShipmentsApi;
/**
 * TagsApi - axios parameter creator
 * @export
 */
const TagsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new Tag for customizing how you track your shipments
         * @summary Create a New Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: (tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tagName' is not null or undefined
            (0, common_1.assertParamExists)('createTag', 'tagName', tagName);
            const localVarPath = `/v1/tags/{tag_name}`
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a tag that is no longer needed
         * @summary Delete Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: (tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tagName' is not null or undefined
            (0, common_1.assertParamExists)('deleteTag', 'tagName', tagName);
            const localVarPath = `/v1/tags/{tag_name}`
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of all tags associated with an account.
         * @summary Get Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Change a tag name while still keeping the relevant shipments attached to it
         * @summary Update Tag Name
         * @param {string} tagName
         * @param {string} newTagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag: (tagName, newTagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tagName' is not null or undefined
            (0, common_1.assertParamExists)('renameTag', 'tagName', tagName);
            // verify required parameter 'newTagName' is not null or undefined
            (0, common_1.assertParamExists)('renameTag', 'newTagName', newTagName);
            const localVarPath = `/v1/tags/{tag_name}/{new_tag_name}`
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)))
                .replace(`{${"new_tag_name"}}`, encodeURIComponent(String(newTagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TagsApiAxiosParamCreator = TagsApiAxiosParamCreator;
/**
 * TagsApi - functional programming interface
 * @export
 */
const TagsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TagsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new Tag for customizing how you track your shipments
         * @summary Create a New Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(tagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTag(tagName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete a tag that is no longer needed
         * @summary Delete Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTag(tagName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get a list of all tags associated with an account.
         * @summary Get Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTags(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Change a tag name while still keeping the relevant shipments attached to it
         * @summary Update Tag Name
         * @param {string} tagName
         * @param {string} newTagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tagName, newTagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.renameTag(tagName, newTagName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TagsApiFp = TagsApiFp;
/**
 * TagsApi - factory interface
 * @export
 */
const TagsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TagsApiFp)(configuration);
    return {
        /**
         * Create a new Tag for customizing how you track your shipments
         * @summary Create a New Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(tagName, options) {
            return localVarFp.createTag(tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag that is no longer needed
         * @summary Delete Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagName, options) {
            return localVarFp.deleteTag(tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all tags associated with an account.
         * @summary Get Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options) {
            return localVarFp.listTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Change a tag name while still keeping the relevant shipments attached to it
         * @summary Update Tag Name
         * @param {string} tagName
         * @param {string} newTagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tagName, newTagName, options) {
            return localVarFp.renameTag(tagName, newTagName, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TagsApiFactory = TagsApiFactory;
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
class TagsApi extends base_1.BaseAPI {
    /**
     * Create a new Tag for customizing how you track your shipments
     * @summary Create a New Tag
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    createTag(tagName, options) {
        return (0, exports.TagsApiFp)(this.configuration).createTag(tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a tag that is no longer needed
     * @summary Delete Tag
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    deleteTag(tagName, options) {
        return (0, exports.TagsApiFp)(this.configuration).deleteTag(tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of all tags associated with an account.
     * @summary Get Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    listTags(options) {
        return (0, exports.TagsApiFp)(this.configuration).listTags(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Change a tag name while still keeping the relevant shipments attached to it
     * @summary Update Tag Name
     * @param {string} tagName
     * @param {string} newTagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    renameTag(tagName, newTagName, options) {
        return (0, exports.TagsApiFp)(this.configuration).renameTag(tagName, newTagName, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TagsApi = TagsApi;
/**
 * TokensApi - axios parameter creator
 * @export
 */
const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
         * @summary Get Ephemeral Token
         * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGetEphemeralToken: (redirect, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/tokens/ephemeral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TokensApiAxiosParamCreator = TokensApiAxiosParamCreator;
/**
 * TokensApi - functional programming interface
 * @export
 */
const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TokensApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
         * @summary Get Ephemeral Token
         * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGetEphemeralToken(redirect, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensGetEphemeralToken(redirect, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TokensApiFp = TokensApiFp;
/**
 * TokensApi - factory interface
 * @export
 */
const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TokensApiFp)(configuration);
    return {
        /**
         * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
         * @summary Get Ephemeral Token
         * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGetEphemeralToken(redirect, options) {
            return localVarFp.tokensGetEphemeralToken(redirect, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TokensApiFactory = TokensApiFactory;
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
class TokensApi extends base_1.BaseAPI {
    /**
     * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
     * @summary Get Ephemeral Token
     * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensGetEphemeralToken(redirect, options) {
        return (0, exports.TokensApiFp)(this.configuration).tokensGetEphemeralToken(redirect, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TokensApi = TokensApi;
/**
 * TrackingApi - axios parameter creator
 * @export
 */
const TrackingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve package tracking information
         * @summary Get Tracking Information
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLog: (carrierCode, trackingNumber, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
         * @summary Start Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTracking: (carrierCode, trackingNumber, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/tracking/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Unsubscribe from tracking updates for a package.
         * @summary Stop Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTracking: (carrierCode, trackingNumber, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/tracking/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TrackingApiAxiosParamCreator = TrackingApiAxiosParamCreator;
/**
 * TrackingApi - functional programming interface
 * @export
 */
const TrackingApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TrackingApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve package tracking information
         * @summary Get Tracking Information
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLog(carrierCode, trackingNumber, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrackingLog(carrierCode, trackingNumber, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
         * @summary Start Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTracking(carrierCode, trackingNumber, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.startTracking(carrierCode, trackingNumber, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Unsubscribe from tracking updates for a package.
         * @summary Stop Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTracking(carrierCode, trackingNumber, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.stopTracking(carrierCode, trackingNumber, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TrackingApiFp = TrackingApiFp;
/**
 * TrackingApi - factory interface
 * @export
 */
const TrackingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TrackingApiFp)(configuration);
    return {
        /**
         * Retrieve package tracking information
         * @summary Get Tracking Information
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLog(carrierCode, trackingNumber, options) {
            return localVarFp.getTrackingLog(carrierCode, trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
         * @summary Start Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTracking(carrierCode, trackingNumber, options) {
            return localVarFp.startTracking(carrierCode, trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe from tracking updates for a package.
         * @summary Stop Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTracking(carrierCode, trackingNumber, options) {
            return localVarFp.stopTracking(carrierCode, trackingNumber, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TrackingApiFactory = TrackingApiFactory;
/**
 * TrackingApi - object-oriented interface
 * @export
 * @class TrackingApi
 * @extends {BaseAPI}
 */
class TrackingApi extends base_1.BaseAPI {
    /**
     * Retrieve package tracking information
     * @summary Get Tracking Information
     * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
     * @param {string} [trackingNumber] The tracking number associated with a shipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    getTrackingLog(carrierCode, trackingNumber, options) {
        return (0, exports.TrackingApiFp)(this.configuration).getTrackingLog(carrierCode, trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
     * @summary Start Tracking a Package
     * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
     * @param {string} [trackingNumber] The tracking number associated with a shipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    startTracking(carrierCode, trackingNumber, options) {
        return (0, exports.TrackingApiFp)(this.configuration).startTracking(carrierCode, trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unsubscribe from tracking updates for a package.
     * @summary Stop Tracking a Package
     * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
     * @param {string} [trackingNumber] The tracking number associated with a shipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    stopTracking(carrierCode, trackingNumber, options) {
        return (0, exports.TrackingApiFp)(this.configuration).stopTracking(carrierCode, trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TrackingApi = TrackingApi;
/**
 * WarehousesApi - axios parameter creator
 * @export
 */
const WarehousesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
         * @summary Create Warehouse
         * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse: (createWarehouseRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createWarehouseRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createWarehouse', 'createWarehouseRequestBody', createWarehouseRequestBody);
            const localVarPath = `/v1/warehouses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWarehouseRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a warehouse by ID
         * @summary Delete Warehouse By ID
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse: (warehouseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'warehouseId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWarehouse', 'warehouseId', warehouseId);
            const localVarPath = `/v1/warehouses/{warehouse_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve warehouse data based on the warehouse ID
         * @summary Get Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseById: (warehouseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'warehouseId' is not null or undefined
            (0, common_1.assertParamExists)('getWarehouseById', 'warehouseId', warehouseId);
            const localVarPath = `/v1/warehouses/{warehouse_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of warehouses associated with this account.
         * @summary List Warehouses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarehouses: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/warehouses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update Warehouse object information
         * @summary Update Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouse: (warehouseId, updateWarehouseRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'warehouseId' is not null or undefined
            (0, common_1.assertParamExists)('updateWarehouse', 'warehouseId', warehouseId);
            // verify required parameter 'updateWarehouseRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updateWarehouse', 'updateWarehouseRequestBody', updateWarehouseRequestBody);
            const localVarPath = `/v1/warehouses/{warehouse_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWarehouseRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update Warehouse settings object information
         * @summary Update Warehouse Settings
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouseSettings: (warehouseId, updateWarehouseSettingsRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'warehouseId' is not null or undefined
            (0, common_1.assertParamExists)('updateWarehouseSettings', 'warehouseId', warehouseId);
            // verify required parameter 'updateWarehouseSettingsRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updateWarehouseSettings', 'updateWarehouseSettingsRequestBody', updateWarehouseSettingsRequestBody);
            const localVarPath = `/v1/warehouses/{warehouse_id}/settings`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWarehouseSettingsRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WarehousesApiAxiosParamCreator = WarehousesApiAxiosParamCreator;
/**
 * WarehousesApi - functional programming interface
 * @export
 */
const WarehousesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WarehousesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
         * @summary Create Warehouse
         * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse(createWarehouseRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWarehouse(createWarehouseRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete a warehouse by ID
         * @summary Delete Warehouse By ID
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse(warehouseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWarehouse(warehouseId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve warehouse data based on the warehouse ID
         * @summary Get Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseById(warehouseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWarehouseById(warehouseId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve a list of warehouses associated with this account.
         * @summary List Warehouses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarehouses(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWarehouses(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update Warehouse object information
         * @summary Update Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouse(warehouseId, updateWarehouseRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWarehouse(warehouseId, updateWarehouseRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update Warehouse settings object information
         * @summary Update Warehouse Settings
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.WarehousesApiFp = WarehousesApiFp;
/**
 * WarehousesApi - factory interface
 * @export
 */
const WarehousesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WarehousesApiFp)(configuration);
    return {
        /**
         * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
         * @summary Create Warehouse
         * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse(createWarehouseRequestBody, options) {
            return localVarFp.createWarehouse(createWarehouseRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a warehouse by ID
         * @summary Delete Warehouse By ID
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse(warehouseId, options) {
            return localVarFp.deleteWarehouse(warehouseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve warehouse data based on the warehouse ID
         * @summary Get Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseById(warehouseId, options) {
            return localVarFp.getWarehouseById(warehouseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of warehouses associated with this account.
         * @summary List Warehouses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarehouses(options) {
            return localVarFp.listWarehouses(options).then((request) => request(axios, basePath));
        },
        /**
         * Update Warehouse object information
         * @summary Update Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouse(warehouseId, updateWarehouseRequestBody, options) {
            return localVarFp.updateWarehouse(warehouseId, updateWarehouseRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Warehouse settings object information
         * @summary Update Warehouse Settings
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options) {
            return localVarFp.updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WarehousesApiFactory = WarehousesApiFactory;
/**
 * WarehousesApi - object-oriented interface
 * @export
 * @class WarehousesApi
 * @extends {BaseAPI}
 */
class WarehousesApi extends base_1.BaseAPI {
    /**
     * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
     * @summary Create Warehouse
     * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    createWarehouse(createWarehouseRequestBody, options) {
        return (0, exports.WarehousesApiFp)(this.configuration).createWarehouse(createWarehouseRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a warehouse by ID
     * @summary Delete Warehouse By ID
     * @param {string} warehouseId Warehouse ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    deleteWarehouse(warehouseId, options) {
        return (0, exports.WarehousesApiFp)(this.configuration).deleteWarehouse(warehouseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve warehouse data based on the warehouse ID
     * @summary Get Warehouse By Id
     * @param {string} warehouseId Warehouse ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    getWarehouseById(warehouseId, options) {
        return (0, exports.WarehousesApiFp)(this.configuration).getWarehouseById(warehouseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of warehouses associated with this account.
     * @summary List Warehouses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    listWarehouses(options) {
        return (0, exports.WarehousesApiFp)(this.configuration).listWarehouses(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Warehouse object information
     * @summary Update Warehouse By Id
     * @param {string} warehouseId Warehouse ID
     * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    updateWarehouse(warehouseId, updateWarehouseRequestBody, options) {
        return (0, exports.WarehousesApiFp)(this.configuration).updateWarehouse(warehouseId, updateWarehouseRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Warehouse settings object information
     * @summary Update Warehouse Settings
     * @param {string} warehouseId Warehouse ID
     * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options) {
        return (0, exports.WarehousesApiFp)(this.configuration).updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WarehousesApi = WarehousesApi;
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
const WebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a webook for specific events in the environment.
         * @summary Create a Webhook
         * @param {CreateWebhookRequestBody} createWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: (createWebhookRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createWebhookRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('createWebhook', 'createWebhookRequestBody', createWebhookRequestBody);
            const localVarPath = `/v1/environment/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWebhookRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a webhook
         * @summary Delete Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: (webhookId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhook', 'webhookId', webhookId);
            const localVarPath = `/v1/environment/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve individual webhook by an ID
         * @summary Get Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookById: (webhookId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('getWebhookById', 'webhookId', webhookId);
            const localVarPath = `/v1/environment/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all webhooks currently enabled for the account.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/environment/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the webhook url property
         * @summary Update a Webhook
         * @param {string} webhookId Webhook ID
         * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: (webhookId, updateWebhookRequestBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'webhookId', webhookId);
            // verify required parameter 'updateWebhookRequestBody' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'updateWebhookRequestBody', updateWebhookRequestBody);
            const localVarPath = `/v1/environment/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWebhookRequestBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a webook for specific events in the environment.
         * @summary Create a Webhook
         * @param {CreateWebhookRequestBody} createWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWebhook(createWebhookRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete a webhook
         * @summary Delete Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhook(webhookId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve individual webhook by an ID
         * @summary Get Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookById(webhookId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWebhookById(webhookId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List all webhooks currently enabled for the account.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhooks(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update the webhook url property
         * @summary Update a Webhook
         * @param {string} webhookId Webhook ID
         * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, updateWebhookRequestBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequestBody, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.WebhooksApiFp = WebhooksApiFp;
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WebhooksApiFp)(configuration);
    return {
        /**
         * Create a webook for specific events in the environment.
         * @summary Create a Webhook
         * @param {CreateWebhookRequestBody} createWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequestBody, options) {
            return localVarFp.createWebhook(createWebhookRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook
         * @summary Delete Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve individual webhook by an ID
         * @summary Get Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookById(webhookId, options) {
            return localVarFp.getWebhookById(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all webhooks currently enabled for the account.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the webhook url property
         * @summary Update a Webhook
         * @param {string} webhookId Webhook ID
         * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, updateWebhookRequestBody, options) {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WebhooksApiFactory = WebhooksApiFactory;
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends base_1.BaseAPI {
    /**
     * Create a webook for specific events in the environment.
     * @summary Create a Webhook
     * @param {CreateWebhookRequestBody} createWebhookRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookRequestBody, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).createWebhook(createWebhookRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a webhook
     * @summary Delete Webhook By ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(webhookId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve individual webhook by an ID
     * @summary Get Webhook By ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhookById(webhookId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhookById(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all webhooks currently enabled for the account.
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhooks(options) {
        return (0, exports.WebhooksApiFp)(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the webhook url property
     * @summary Update a Webhook
     * @param {string} webhookId Webhook ID
     * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(webhookId, updateWebhookRequestBody, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).updateWebhook(webhookId, updateWebhookRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WebhooksApi = WebhooksApi;
