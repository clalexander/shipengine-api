/* tslint:disable */
/* eslint-disable */
/**
 * ShipEngine API
 * ShipEngine\'s easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.  Each of ShipEngine\'s features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.  ## Getting Started If you\'re new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.  Here are some step-by-step **tutorials** to get you started:    - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)   - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)   - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)   - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)   ## Shipping Labels for Every Major Carrier ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).   ## Real-Time Package Tracking With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.   ## Compare Shipping Costs Across Carriers Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don\'t know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.   ## Worldwide Address Validation ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others.
 *
 * The version of the OpenAPI document: 1.1.202307171907
 * Contact: sales@shipengine.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base';
export const AccountSettingsImagesImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
/**
 * Indicates whether an address is residential.
 * @export
 * @enum {string}
 */
export const AddressResidentialIndicator = {
    Unknown: 'unknown',
    Yes: 'yes',
    No: 'no'
};
/**
 * The error codes that can be returned by the address validation API
 * @export
 * @enum {string}
 */
export const AddressValidationCode = {
    A1000: 'a1000',
    A1001: 'a1001',
    A1002: 'a1002',
    A1003: 'a1003',
    A1004: 'a1004',
    A1005: 'a1005',
    A1006: 'a1006',
    A1007: 'a1007',
    A1008: 'a1008',
    R1000: 'r1000',
    R1001: 'r1001',
    R1002: 'r1002',
    R1003: 'r1003'
};
/**
 * The detailed error codes that can be returned by the address validation API
 * @export
 * @enum {string}
 */
export const AddressValidationDetailCode = {
    UnsupportedCountry: 'unsupported_country',
    NonSupportedCountry: 'non_supported_country',
    MinimumPostalCodeVerificationFailed: 'minimum_postal_code_verification_failed',
    StreetDoesNotMatchUniqueStreetName: 'street_does_not_match_unique_street_name',
    MultipleDirectionals: 'multiple_directionals',
    MultipleMatches: 'multiple_matches',
    SuiteNotValid: 'suite_not_valid',
    SuiteMissing: 'suite_missing',
    IncompatiblePairedLabels: 'incompatible_paired_labels',
    InvalidHouseNumber: 'invalid_house_number',
    MissingHouseNumber: 'missing_house_number',
    InvalidBoxNumber: 'invalid_box_number',
    InvalidChargeEvent: 'invalid_charge_event',
    MissingBoxNumber: 'missing_box_number',
    MissingCmraOrPrivateMailBoxNumber: 'missing_cmra_or_private_mail_box_number',
    SuiteHasNoSecondaries: 'suite_has_no_secondaries',
    PostalCodeChangedOrAdded: 'postal_code_changed_or_added',
    StateProvinceChangedOrAdded: 'state_province_changed_or_added',
    CityLocalityChangedOrAdded: 'city_locality_changed_or_added',
    UrbanizationChanged: 'urbanization_changed',
    StreetNameSpellingChangedOrAdded: 'street_name_spelling_changed_or_added',
    StreetNameTypeChangedOrAdded: 'street_name_type_changed_or_added',
    StreetDirectionChangedOrAdded: 'street_direction_changed_or_added',
    SuiteTypeChangedOrAdded: 'suite_type_changed_or_added',
    SuiteUnitNumberChangedOrAdded: 'suite_unit_number_changed_or_added',
    DoubleDependentLocalityChangedOrAdded: 'double_dependent_locality_changed_or_added',
    SubadministrativeAreaChangedOrAdded: 'subadministrative_area_changed_or_added',
    SubnationalAreaChangedOrAdded: 'subnational_area_changed_or_added',
    PoBoxChangedOrAdded: 'po_box_changed_or_added',
    PremiseTypeChangedOrAdded: 'premise_type_changed_or_added',
    HouseNumberChanged: 'house_number_changed',
    OrganizationChangedOrAdded: 'organization_changed_or_added',
    PartiallyVerifiedToStateLevel: 'partially_verified_to_state_level',
    PartiallyVerifiedToCityLevel: 'partially_verified_to_city_level',
    PartiallyVerifiedToStreetLevel: 'partially_verified_to_street_level',
    PartiallyVerifiedToPremiseLevel: 'partially_verified_to_premise_level',
    VerifiedToStateLevel: 'verified_to_state_level',
    VerifiedToCityLevel: 'verified_to_city_level',
    VerifiedToStreetLevel: 'verified_to_street_level',
    VerifiedToPremiseLevel: 'verified_to_premise_level',
    VerifiedToSuiteLevel: 'verified_to_suite_level',
    CodedToStreetLavel: 'coded_to_street_lavel',
    CodedToNeighborhoodLevel: 'coded_to_neighborhood_level',
    CodedToCommunityLevel: 'coded_to_community_level',
    CodedToStateLevel: 'coded_to_state_level',
    CodedToRooftopLevel: 'coded_to_rooftop_level',
    CodedToRooftopInterpolationLevel: 'coded_to_rooftop_interpolation_level',
    NameMaxLengthExceeded: 'name_max_length_exceeded',
    PhoneMaxLengthExceeded: 'phone_max_length_exceeded',
    CompanyNameMaxLengthExceeded: 'company_name_max_length_exceeded',
    Line1MinMaxLength: 'line1_min_max_length',
    Line2MaxLengthExceeded: 'line2_max_length_exceeded',
    Line3MaxLengthExceeded: 'line3_max_length_exceeded',
    CityLocalityMaxLengthExceeded: 'city_locality_max_length_exceeded',
    StateProvinceMaxLengthExceeded: 'state_province_max_length_exceeded',
    InvalidPostalCode: 'invalid_postal_code',
    CountryInvalidLength: 'country_invalid_length',
    AddressNotFound: 'address_not_found'
};
/**
 * The different types of messages that can be returned by the address validation API
 * @export
 * @enum {string}
 */
export const AddressValidationMessageType = {
    Error: 'error',
    Warning: 'warning',
    Info: 'info'
};
/**
 * The possible address validation status values
 * @export
 * @enum {string}
 */
export const AddressValidationStatus = {
    Unverified: 'unverified',
    Verified: 'verified',
    Warning: 'warning',
    Error: 'error'
};
/**
 *
 * @export
 * @enum {string}
 */
export const AllowedIncoterms = {
    Exw: 'exw',
    Fca: 'fca',
    Cpt: 'cpt',
    Cip: 'cip',
    Dpu: 'dpu',
    Dap: 'dap',
    Ddp: 'ddp',
    Fas: 'fas',
    Fob: 'fob',
    Cfr: 'cfr',
    Cif: 'cif',
    Ddu: 'ddu',
    Daf: 'daf',
    Deq: 'deq',
    Des: 'des'
};
/**
 * [Ancillary service endorsements](https://pe.usps.com/text/qsg300/Q507.htm) are used by mailers to request an addressee\'s new address and to provide the carrier with instructions on how to handle packages that are undeliverable as addressed.  | Ancillary Service Endorsement  | Description |--------------------------------|----------------------------------------------------- | `none`                         | No ancillary service is requested. Depending on the carrier servive, the package may be forwarded, returned, or discarded. | `return_service_requested`     | The package is returned to the sender. If possible, notification of the new address is is included with the returned package. | `forwarding_service_requested` | Forward the package to the new address, if possible; otherwise, return it to the sender. | `address_service_requested`    | Forward the package to the new address, if possible; otherwise, return it to the sender. This is similar to `forwarding_service_requested`, but different restrictions and charges may apply. | `change_service_requested`     | The package is discarded. If possible, notification of the new address is sent to the sender. | `leave_if_no_response`         |
 * @export
 * @enum {string}
 */
export const AncillaryServiceEndorsement = {
    None: 'none',
    ReturnServiceRequested: 'return_service_requested',
    ForwardingServiceRequested: 'forwarding_service_requested',
    AddressServiceRequested: 'address_service_requested',
    ChangeServiceRequested: 'change_service_requested',
    LeaveIfNoResponse: 'leave_if_no_response'
};
/**
 * The possible batch status values
 * @export
 * @enum {string}
 */
export const BatchStatus = {
    Open: 'open',
    Queued: 'queued',
    Processing: 'processing',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors',
    Archived: 'archived',
    Notifying: 'notifying',
    Invalid: 'invalid'
};
/**
 * The possible batches sort by values
 * @export
 * @enum {string}
 */
export const BatchesSortBy = {
    ShipDate: 'ship_date',
    ProcessedAt: 'processed_at',
    CreatedAt: 'created_at'
};
/**
 * The possible bill to party values
 * @export
 * @enum {string}
 */
export const BillToParty = {
    Recipient: 'recipient',
    ThirdParty: 'third_party'
};
/**
 * The shipping carriers that are supported by ShipEngine
 * @export
 * @enum {string}
 */
export const CarrierName = {
    AccessWorldwide: 'access_worldwide',
    AmazonBuyShipping: 'amazon_buy_shipping',
    AmazonShippingUk: 'amazon_shipping_uk',
    Apc: 'apc',
    Asendia: 'asendia',
    AustraliaPost: 'australia_post',
    CanadaPost: 'canada_post',
    DhlEcommerce: 'dhl_ecommerce',
    DhlExpress: 'dhl_express',
    DhlExpressAu: 'dhl_express_au',
    DhlExpressCa: 'dhl_express_ca',
    DhlExpressUk: 'dhl_express_uk',
    Dpd: 'dpd',
    Endicia: 'endicia',
    Fedex: 'fedex',
    FedexUk: 'fedex_uk',
    Firstmile: 'firstmile',
    Imex: 'imex',
    Newgistics: 'newgistics',
    Ontrac: 'ontrac',
    PurolatorCanada: 'purolator_canada',
    RoyalMail: 'royal_mail',
    RrDonnelley: 'rr_donnelley',
    Seko: 'seko',
    Sendle: 'sendle',
    StampsCom: 'stamps_com',
    Ups: 'ups'
};
/**
 * The shipping carriers for which ShipEngine supports carrier settings
 * @export
 * @enum {string}
 */
export const CarrierNameWithSettings = {
    DhlExpress: 'dhl_express',
    Fedex: 'fedex',
    Newgistics: 'newgistics',
    Ups: 'ups'
};
/**
 * Types of payment that are supported
 * @export
 * @enum {string}
 */
export const CollectOnDeliveryPaymentType = {
    Any: 'any',
    Cash: 'cash',
    CashEquivalent: 'cash_equivalent',
    None: 'none'
};
export const CreateAccountSettingsImageRequestBodyImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
/**
 * The possible default label layout values
 * @export
 * @enum {string}
 */
export const DefaultLabelLayout = {
    _4x6: '4x6',
    Letter: 'Letter'
};
/**
 * The possible delivery confirmation values
 * @export
 * @enum {string}
 */
export const DeliveryConfirmation = {
    None: 'none',
    Delivery: 'delivery',
    Signature: 'signature',
    AdultSignature: 'adult_signature',
    DirectSignature: 'direct_signature',
    DeliveryMailed: 'delivery_mailed',
    VerbalConfirmation: 'verbal_confirmation'
};
/**
 * The dimension units that are supported by ShipEngine.
 * @export
 * @enum {string}
 */
export const DimensionUnit = {
    Inch: 'inch',
    Centimeter: 'centimeter'
};
/**
 * The display format that the label should be shown in.
 * @export
 * @enum {string}
 */
export const DisplayScheme = {
    Label: 'label',
    QrCode: 'qr_code',
    LabelAndQrCode: 'label_and_qr_code'
};
/**
 * The error code specified for the failed API Call
 * @export
 * @enum {string}
 */
export const ErrorCode = {
    AutoFundNotSupported: 'auto_fund_not_supported',
    BatchCannotBeModified: 'batch_cannot_be_modified',
    CarrierConflict: 'carrier_conflict',
    CarrierDisconnected: 'carrier_disconnected',
    CarrierNotConnected: 'carrier_not_connected',
    CarrierNotSupported: 'carrier_not_supported',
    ConfirmationNotSupported: 'confirmation_not_supported',
    DefaultWarehouseCannotBeDeleted: 'default_warehouse_cannot_be_deleted',
    FieldConflict: 'field_conflict',
    FieldValueRequired: 'field_value_required',
    Forbidden: 'forbidden',
    IdentifierConflict: 'identifier_conflict',
    IdentifiersMustMatch: 'identifiers_must_match',
    InsufficientFunds: 'insufficient_funds',
    InvalidAddress: 'invalid_address',
    InvalidBillingPlan: 'invalid_billing_plan',
    InvalidFieldValue: 'invalid_field_value',
    InvalidIdentifier: 'invalid_identifier',
    InvalidStatus: 'invalid_status',
    InvalidStringLength: 'invalid_string_length',
    LabelImagesNotSupported: 'label_images_not_supported',
    MeterFailure: 'meter_failure',
    OrderSourceNotActive: 'order_source_not_active',
    RateLimitExceeded: 'rate_limit_exceeded',
    RefreshNotSupported: 'refresh_not_supported',
    RequestBodyRequired: 'request_body_required',
    ReturnLabelNotSupported: 'return_label_not_supported',
    SettingsNotSupported: 'settings_not_supported',
    SubscriptionInactive: 'subscription_inactive',
    TermsNotAccepted: 'terms_not_accepted',
    TrackingNotSupported: 'tracking_not_supported',
    TrialExpired: 'trial_expired',
    Unauthorized: 'unauthorized',
    Unknown: 'unknown',
    Unspecified: 'unspecified',
    VerificationFailure: 'verification_failure',
    WarehouseConflict: 'warehouse_conflict',
    WebhookEventTypeConflict: 'webhook_event_type_conflict'
};
/**
 * The source of the error, as indicated by the name this informs us if the API call failed because of the carrier, the order source, or the ShipEngine API itself.
 * @export
 * @enum {string}
 */
export const ErrorSource = {
    Carrier: 'carrier',
    OrderSource: 'order_source',
    Shipengine: 'shipengine'
};
/**
 * The type of error
 * @export
 * @enum {string}
 */
export const ErrorType = {
    AccountStatus: 'account_status',
    BusinessRules: 'business_rules',
    Validation: 'validation',
    Security: 'security',
    System: 'system',
    Integrations: 'integrations'
};
/**
 * Determines how FedEx will pickup your packages  |Pickup Type               |Description |--------------------------|----------------------------------------- |`none`                    | Not specified |`regular_pickup`          | You already have a daily pickup scheduled with FedEx |`request_courier`         | You will call FedEx to request a courier |`drop_box`                | You will drop-off packages in a FedEx drop box |`business_service_center` | You will drop-off packages at an authorized FedEx business service center |`station`                 | You will drop-off the package at a FedEx Station
 * @export
 * @enum {string}
 */
export const FedexPickupType = {
    None: 'none',
    RegularPickup: 'regular_pickup',
    RequestCourier: 'request_courier',
    DropBox: 'drop_box',
    BusinessServiceCenter: 'business_service_center',
    Station: 'station'
};
export const GetAccountSettingsImagesResponseBodyImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
export const GetServicePointByIdResponseBodyServicePointFeaturesEnum = {
    DropOffPoint: 'drop_off_point',
    PickupPoint: 'pickup_point',
    PrintServices: 'print_services',
    AfterHoursLocker: 'after_hours_locker',
    AfterHoursDropbox: 'after_hours_dropbox'
};
export const GetServicePointByIdResponseBodyServicePointTypeEnum = {
    Pudo: 'pudo',
    Locker: 'locker'
};
/**
 * Determines how FedEx will pickup your packages  |Pickup Type    | Description |---------------|----------------------------------------- |`vat`          | The tax identifier is a Value Added Tax. |`eori`         | The tax identifier is an Economic Operators Registration and Identification Number (EORI). |`ssn`          | The tax identifier is a Social Security Number. |`ein`          | The tax identifier is an Employer Identification Number (EIN). |`tin`          | The tax identifier is a Tax Identification Number (TIN). |`ioss`         | The tax identifier is an Import One-Stop Shop (IOSS). |`pan`          | The tax identifier is a Permanent Account Number (PAN). |`voec`         | The tax identifier is a Norwegian VAT On E-Commerce(VOEC). |`pccc`         | The tax identifier is a Personal Customs Clearance Code (PCCC). |`oss`          | The tax identifier is an One-Stop Shop (OSS). |`passport`     | The tax identifier is a Passport Number. |`abn`          | The tax identifier is an Australian Business Number.
 * @export
 * @enum {string}
 */
export const IdentifierType = {
    Vat: 'vat',
    Eori: 'eori',
    Ssn: 'ssn',
    Ein: 'ein',
    Tin: 'tin',
    Ioss: 'ioss',
    Pan: 'pan',
    Voec: 'voec',
    Pccc: 'pccc',
    Oss: 'oss',
    Passport: 'passport',
    Abn: 'abn'
};
/**
 * The possible insurance provider values
 * @export
 * @enum {string}
 */
export const InsuranceProvider = {
    None: 'none',
    Shipsurance: 'shipsurance',
    Carrier: 'carrier',
    ThirdParty: 'third_party'
};
/**
 * Determines when the user\'s account will be charged for the label.
 * @export
 * @enum {string}
 */
export const LabelChargeEvent = {
    CarrierDefault: 'carrier_default',
    OnCreation: 'on_creation',
    OnCarrierAcceptance: 'on_carrier_acceptance'
};
/**
 * There are two different ways to [download a label](https://www.shipengine.com/docs/labels/downloading/):  |Label Download Type | Description |--------------------|------------------------------ |`url`               |You will receive a URL, which you can use to download the label in a separate request. The URL will remain valid for 90 days.<br><br>This is the default if `label_download_type` is unspecified. |`inline`            |You will receive the Base64-encoded label as part of the response. No need for a second request to download the label.
 * @export
 * @enum {string}
 */
export const LabelDownloadType = {
    Url: 'url',
    Inline: 'inline'
};
/**
 * The possible file formats in which shipping labels can be downloaded.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.  |Label Format  | Supported Carriers |--------------|----------------------------------- |`pdf`         | All carriers |`png`         | `fedex` <br> `stamps_com` <br> `ups` <br> `usps` |`zpl`         | `access_worldwide` <br> `apc` <br> `asendia` <br> `dhl_global_mail` <br> `dhl_express` <br> `dhl_express_australia` <br> `dhl_express_canada` <br> `dhl_express_worldwide` <br> `dhl_express_uk` <br> `dpd` <br> `endicia` <br> `fedex` <br> `fedex_uk` <br> `firstmile` <br> `imex` <br> `newgistics` <br> `ontrac` <br> `rr_donnelley` <br> `stamps_com` <br> `ups` <br> `usps`
 * @export
 * @enum {string}
 */
export const LabelFormat = {
    Pdf: 'pdf',
    Png: 'png',
    Zpl: 'zpl'
};
/**
 * The available layouts (sizes) in which shipping labels can be downloaded.  The label format determines which sizes are supported.  `4x6` is supported for all label formats, whereas `letter` (8.5\" x 11\") is only supported for `pdf` format.
 * @export
 * @enum {string}
 */
export const LabelLayout = {
    _4x6: '4x6',
    Letter: 'letter'
};
/**
 * The possible statuses that a [shipping label](https://www.shipengine.com/docs/labels/create-a-label/) can be in.  |Status       |Description |:------------|:----------------------------------------------------- |`processing` |When labels are created in a [batch](https://www.shipengine.com/docs/labels/bulk/), it may take a few minutes for all of the labels in the batch to be created.  During this period, they will be in `processing` status. |`completed`  |The label was successfully created |`error`      |The label could not be created due to an error, such as an invalid delivery address |`voided`     |The label has been [voided](https://www.shipengine.com/docs/labels/voiding/)
 * @export
 * @enum {string}
 */
export const LabelStatus = {
    Processing: 'processing',
    Completed: 'completed',
    Error: 'error',
    Voided: 'voided'
};
export const ListServicePointsResponseBodyServicePointsInnerFeaturesEnum = {
    DropOffPoint: 'drop_off_point',
    PickupPoint: 'pickup_point',
    PrintServices: 'print_services',
    AfterHoursLocker: 'after_hours_locker',
    AfterHoursDropbox: 'after_hours_dropbox'
};
export const ListServicePointsResponseBodyServicePointsInnerTypeEnum = {
    Pudo: 'pudo',
    Locker: 'locker'
};
/**
 * The possible statuses of a manifest request
 * @export
 * @enum {string}
 */
export const ManifestRequestStatus = {
    InProgress: 'in_progress',
    Completed: 'completed'
};
/**
 * The possible non delivery values
 * @export
 * @enum {string}
 */
export const NonDelivery = {
    ReturnToSender: 'return_to_sender',
    TreatAsAbandoned: 'treat_as_abandoned'
};
/**
 * The order sources that are supported by ShipEngine
 * @export
 * @enum {string}
 */
export const OrderSourceName = {
    AmazonCa: 'amazon_ca',
    AmazonUs: 'amazon_us',
    Brightpearl: 'brightpearl',
    ChannelAdvisor: 'channel_advisor',
    Cratejoy: 'cratejoy',
    Ebay: 'ebay',
    Etsy: 'etsy',
    Jane: 'jane',
    GrouponGoods: 'groupon_goods',
    Magento: 'magento',
    Paypal: 'paypal',
    SellerActive: 'seller_active',
    Shopify: 'shopify',
    StitchLabs: 'stitch_labs',
    Squarespace: 'squarespace',
    ThreeDcart: 'three_dcart',
    Tophatter: 'tophatter',
    Walmart: 'walmart',
    WooCommerce: 'woo_commerce',
    Volusion: 'volusion'
};
/**
 * Indicates if the package will be picked up or dropped off by the carrier
 * @export
 * @enum {string}
 */
export const OriginType = {
    Pickup: 'pickup',
    DropOff: 'drop_off'
};
/**
 * The possible package contents values
 * @export
 * @enum {string}
 */
export const PackageContents = {
    Merchandise: 'merchandise',
    Documents: 'documents',
    Gift: 'gift',
    ReturnedGoods: 'returned_goods',
    Sample: 'sample',
    Other: 'other'
};
/**
 * The possible rate response status values
 * @export
 * @enum {string}
 */
export const RateResponseStatus = {
    Working: 'working',
    Completed: 'completed',
    Partial: 'partial',
    Error: 'error'
};
/**
 * The possible rate type values
 * @export
 * @enum {string}
 */
export const RateType = {
    Check: 'check',
    Shipment: 'shipment'
};
/**
 * The possible normalized reasons a label void request may not have been approved
 * @export
 * @enum {string}
 */
export const ReasonCode = {
    Unknown: 'unknown',
    Unspecified: 'unspecified',
    ValidationFailed: 'validation_failed',
    LabelNotFoundWithinVoidPeriod: 'label_not_found_within_void_period',
    LabelAlreadyUsed: 'label_already_used',
    LabelAlreadyVoided: 'label_already_voided',
    ContactCarrier: 'contact_carrier'
};
/**
 * The resource to return a redirect URL to.
 * @export
 * @enum {string}
 */
export const Redirect = {
    ShipengineDashboard: 'shipengine-dashboard'
};
/**
 * The possible shipment status values
 * @export
 * @enum {string}
 */
export const ShipmentStatus = {
    Pending: 'pending',
    Processing: 'processing',
    LabelPurchased: 'label_purchased',
    Cancelled: 'cancelled'
};
/**
 * The possible shipments sort by values
 * @export
 * @enum {string}
 */
export const ShipmentsSortBy = {
    ModifiedAt: 'modified_at',
    CreatedAt: 'created_at'
};
/**
 * The possible smart post hub values
 * @export
 * @enum {string}
 */
export const SmartPostHub = {
    None: 'none',
    AllentownPa: 'allentown_pa',
    AtlantaGa: 'atlanta_ga',
    BaltimoreMd: 'baltimore_md',
    CharlotteNc: 'charlotte_nc',
    ChinoCa: 'chino_ca',
    DallasTx: 'dallas_tx',
    DenverCo: 'denver_co',
    DetroitMi: 'detroit_mi',
    EdisonNj: 'edison_nj',
    GroveCityOh: 'grove_city_oh',
    GroveportOh: 'groveport_oh',
    HoustonTx: 'houston_tx',
    IndianapolisIn: 'indianapolis_in',
    KansasCityKs: 'kansas_city_ks',
    LosAngelesCa: 'los_angeles_ca',
    MartinsburgWv: 'martinsburg_wv',
    MemphisTn: 'memphis_tn',
    MinneapolisMn: 'minneapolis_mn',
    NewBerlinWi: 'new_berlin_wi',
    NorthboroughMa: 'northborough_ma',
    OrlandoFl: 'orlando_fl',
    PhoneixAz: 'phoneix_az',
    PittsburghPa: 'pittsburgh_pa',
    RenoNv: 'reno_nv',
    SacramentoCa: 'sacramento_ca',
    SaltLakeCityUt: 'salt_lake_city_ut',
    SeattleWa: 'seattle_wa',
    StLouisMo: 'st_louis_mo',
    WindsorCt: 'windsor_ct',
    NewarkNy: 'newark_ny',
    SouthBrunswickNj: 'south_brunswick_nj',
    ScrantonPa: 'scranton_pa',
    WheelingIl: 'wheeling_il'
};
/**
 * Controls the sort order of queries  |Value     |Description |:---------|:----------------------------------------------------- |`asc`     |Return results in ascending order |`desc`    |Return results in descending order
 * @export
 * @enum {string}
 */
export const SortDir = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * The tracking status codes  |Value       |Description |:---------  |:----------------------------------------------------- |`un` | Unknown |`ac` | Accepted |`it` | In Transit |`de` | Delivered |`ex` | Exception |`at` | Delivery Attempt |`ny` | Not Yet In System
 * @export
 * @enum {string}
 */
export const StatusCode = {
    Un: 'un',
    Ac: 'ac',
    It: 'it',
    De: 'de',
    Ex: 'ex',
    At: 'at',
    Ny: 'ny'
};
/**
 * The taxable entity type for this tax item. Valid values include the following  |Value       |Description |:---------  |:----------------------------------------------------- |`shipper`   | The shipper is responsible for this tax. |`recipient` | The recipient of the shipment is responsible for this tax. |`ior`       | The importer of records is responsible for tax.
 * @export
 * @enum {string}
 */
export const TaxableEntityType = {
    Shipper: 'shipper',
    Recipient: 'recipient',
    Ior: 'ior'
};
/**
 * The different statuses that can apply to a shipment.
 * @export
 * @enum {string}
 */
export const TrackingStatus = {
    Unknown: 'unknown',
    InTransit: 'in_transit',
    Error: 'error',
    Delivered: 'delivered'
};
export const UpdateAccountSettingsImageRequestBodyImageContentTypeEnum = {
    Png: 'image/png',
    Jpeg: 'image/jpeg'
};
/**
 * The possible ups pickup type values
 * @export
 * @enum {string}
 */
export const UpsPickupType = {
    DailyPickup: 'daily_pickup',
    OccasionalPickup: 'occasional_pickup',
    CustomerCounter: 'customer_counter'
};
/**
 * The possible validate address values
 * @export
 * @enum {string}
 */
export const ValidateAddress = {
    NoValidation: 'no_validation',
    ValidateOnly: 'validate_only',
    ValidateAndClean: 'validate_and_clean'
};
/**
 * The possible validation status values
 * @export
 * @enum {string}
 */
export const ValidationStatus = {
    Valid: 'valid',
    Invalid: 'invalid',
    HasWarnings: 'has_warnings',
    Unknown: 'unknown'
};
/**
 * The possible webook event values
 * @export
 * @enum {string}
 */
export const WebhookEvent = {
    Batch: 'batch',
    CarrierConnected: 'carrier_connected',
    OrderSourceRefreshComplete: 'order_source_refresh_complete',
    Rate: 'rate',
    ReportComplete: 'report_complete',
    SalesOrdersImported: 'sales_orders_imported',
    Track: 'track'
};
/**
 * The possible weight unit values
 * @export
 * @enum {string}
 */
export const WeightUnit = {
    Pound: 'pound',
    Ounce: 'ounce',
    Gram: 'gram',
    Kilogram: 'kilogram'
};
/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create an Account Image
         * @summary Create an Account Image
         * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountImage: async (createAccountSettingsImageRequestBody, options = {}) => {
            // verify required parameter 'createAccountSettingsImageRequestBody' is not null or undefined
            assertParamExists('createAccountImage', 'createAccountSettingsImageRequestBody', createAccountSettingsImageRequestBody);
            const localVarPath = `/v1/account/settings/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountSettingsImageRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Account Image By Id
         * @summary Delete Account Image By Id
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountImageById: async (labelImageId, options = {}) => {
            // verify required parameter 'labelImageId' is not null or undefined
            assertParamExists('deleteAccountImageById', 'labelImageId', labelImageId);
            const localVarPath = `/v1/account/settings/images/{label_image_id}`
                .replace(`{${"label_image_id"}}`, encodeURIComponent(String(labelImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for an account image.
         * @summary Get Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettingsImagesById: async (labelImageId, options = {}) => {
            // verify required parameter 'labelImageId' is not null or undefined
            assertParamExists('getAccountSettingsImagesById', 'labelImageId', labelImageId);
            const localVarPath = `/v1/account/settings/images/{label_image_id}`
                .replace(`{${"label_image_id"}}`, encodeURIComponent(String(labelImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all account images for the ShipEngine account
         * @summary List Account Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountImages: async (options = {}) => {
            const localVarPath = `/v1/account/settings/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all account settings for the ShipEngine account
         * @summary List Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountSettings: async (options = {}) => {
            const localVarPath = `/v1/account/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for an account image.
         * @summary Update Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettingsImagesById: async (labelImageId, updateAccountSettingsImageRequestBody, options = {}) => {
            // verify required parameter 'labelImageId' is not null or undefined
            assertParamExists('updateAccountSettingsImagesById', 'labelImageId', labelImageId);
            // verify required parameter 'updateAccountSettingsImageRequestBody' is not null or undefined
            assertParamExists('updateAccountSettingsImagesById', 'updateAccountSettingsImageRequestBody', updateAccountSettingsImageRequestBody);
            const localVarPath = `/v1/account/settings/images/{label_image_id}`
                .replace(`{${"label_image_id"}}`, encodeURIComponent(String(labelImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountSettingsImageRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
    return {
        /**
         * Create an Account Image
         * @summary Create an Account Image
         * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountImage(createAccountSettingsImageRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountImage(createAccountSettingsImageRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Account Image By Id
         * @summary Delete Account Image By Id
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountImageById(labelImageId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountImageById(labelImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for an account image.
         * @summary Get Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSettingsImagesById(labelImageId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSettingsImagesById(labelImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all account images for the ShipEngine account
         * @summary List Account Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountImages(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountImages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all account settings for the ShipEngine account
         * @summary List Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountSettings(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update information for an account image.
         * @summary Update Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AccountApiFp(configuration);
    return {
        /**
         * Create an Account Image
         * @summary Create an Account Image
         * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountImage(createAccountSettingsImageRequestBody, options) {
            return localVarFp.createAccountImage(createAccountSettingsImageRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Account Image By Id
         * @summary Delete Account Image By Id
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountImageById(labelImageId, options) {
            return localVarFp.deleteAccountImageById(labelImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for an account image.
         * @summary Get Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettingsImagesById(labelImageId, options) {
            return localVarFp.getAccountSettingsImagesById(labelImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all account images for the ShipEngine account
         * @summary List Account Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountImages(options) {
            return localVarFp.listAccountImages(options).then((request) => request(axios, basePath));
        },
        /**
         * List all account settings for the ShipEngine account
         * @summary List Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountSettings(options) {
            return localVarFp.listAccountSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for an account image.
         * @summary Update Account Image By ID
         * @param {string} labelImageId Label Image Id
         * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options) {
            return localVarFp.updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Create an Account Image
     * @summary Create an Account Image
     * @param {CreateAccountSettingsImageRequestBody} createAccountSettingsImageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    createAccountImage(createAccountSettingsImageRequestBody, options) {
        return AccountApiFp(this.configuration).createAccountImage(createAccountSettingsImageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete Account Image By Id
     * @summary Delete Account Image By Id
     * @param {string} labelImageId Label Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    deleteAccountImageById(labelImageId, options) {
        return AccountApiFp(this.configuration).deleteAccountImageById(labelImageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve information for an account image.
     * @summary Get Account Image By ID
     * @param {string} labelImageId Label Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountSettingsImagesById(labelImageId, options) {
        return AccountApiFp(this.configuration).getAccountSettingsImagesById(labelImageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all account images for the ShipEngine account
     * @summary List Account Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    listAccountImages(options) {
        return AccountApiFp(this.configuration).listAccountImages(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all account settings for the ShipEngine account
     * @summary List Account Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    listAccountSettings(options) {
        return AccountApiFp(this.configuration).listAccountSettings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update information for an account image.
     * @summary Update Account Image By ID
     * @param {string} labelImageId Label Image Id
     * @param {UpdateAccountSettingsImageRequestBody} updateAccountSettingsImageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options) {
        return AccountApiFp(this.configuration).updateAccountSettingsImagesById(labelImageId, updateAccountSettingsImageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse an address
         * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseAddress: async (parseAddressRequestBody, options = {}) => {
            // verify required parameter 'parseAddressRequestBody' is not null or undefined
            assertParamExists('parseAddress', 'parseAddressRequestBody', parseAddressRequestBody);
            const localVarPath = `/v1/addresses/recognize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(parseAddressRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
         * @summary Validate An Address
         * @param {Array<AddressToValidate>} addressToValidate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: async (addressToValidate, options = {}) => {
            // verify required parameter 'addressToValidate' is not null or undefined
            assertParamExists('validateAddress', 'addressToValidate', addressToValidate);
            const localVarPath = `/v1/addresses/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addressToValidate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
    return {
        /**
         * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse an address
         * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseAddress(parseAddressRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseAddress(parseAddressRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
         * @summary Validate An Address
         * @param {Array<AddressToValidate>} addressToValidate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(addressToValidate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAddress(addressToValidate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AddressesApiFp(configuration);
    return {
        /**
         * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse an address
         * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseAddress(parseAddressRequestBody, options) {
            return localVarFp.parseAddress(parseAddressRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
         * @summary Validate An Address
         * @param {Array<AddressToValidate>} addressToValidate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress(addressToValidate, options) {
            return localVarFp.validateAddress(addressToValidate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * The address-recognition API makes it easy for you to extract address data from unstructured text, including the recipient name, line 1, line 2, city, postal code, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s address-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed address data is returned in the same structure that\'s used for other ShipEngine APIs, such as address validation, rate quotes, and shipping labels.  > **Note:** Address recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
     * @summary Parse an address
     * @param {ParseAddressRequestBody} parseAddressRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide an &#x60;address&#x60; containing already-known values. For example, you may already know the recipient\&#39;s name, city, and country, and only want to parse the street address into separate lines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    parseAddress(parseAddressRequestBody, options) {
        return AddressesApiFp(this.configuration).parseAddress(parseAddressRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Address validation ensures accurate addresses and can lead to reduced shipping costs by preventing address correction surcharges. ShipEngine cross references multiple databases to validate addresses and identify potential deliverability issues.
     * @summary Validate An Address
     * @param {Array<AddressToValidate>} addressToValidate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    validateAddress(addressToValidate, options) {
        return AddressesApiFp(this.configuration).validateAddress(addressToValidate, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a Shipment or Rate to a Batch
         * @summary Add to a Batch
         * @param {string} batchId Batch ID
         * @param {AddToBatchRequestBody} addToBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch: async (batchId, addToBatchRequestBody, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('addToBatch', 'batchId', batchId);
            // verify required parameter 'addToBatchRequestBody' is not null or undefined
            assertParamExists('addToBatch', 'addToBatchRequestBody', addToBatchRequestBody);
            const localVarPath = `/v1/batches/{batch_id}/add`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addToBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Batch
         * @summary Create A Batch
         * @param {CreateBatchRequestBody} createBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: async (createBatchRequestBody, options = {}) => {
            // verify required parameter 'createBatchRequestBody' is not null or undefined
            assertParamExists('createBatch', 'createBatchRequestBody', createBatchRequestBody);
            const localVarPath = `/v1/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Batch By Id
         * @summary Delete Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch: async (batchId, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('deleteBatch', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Batch By External ID
         * @summary Get Batch By External ID
         * @param {string} externalBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId: async (externalBatchId, options = {}) => {
            // verify required parameter 'externalBatchId' is not null or undefined
            assertParamExists('getBatchByExternalId', 'externalBatchId', externalBatchId);
            const localVarPath = `/v1/batches/external_batch_id/{external_batch_id}`
                .replace(`{${"external_batch_id"}}`, encodeURIComponent(String(externalBatchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Batch By ID
         * @summary Get Batch By ID
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById: async (batchId, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchById', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
         * @summary Get Batch Errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pagesize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors: async (batchId, page, pagesize, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('listBatchErrors', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}/errors`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pagesize !== undefined) {
                localVarQueryParameter['pagesize'] = pagesize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Batches associated with your Shipengine account
         * @summary List Batches
         * @param {BatchStatus} [status]
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches: async (status, page, pageSize, sortDir, batchNumber, sortBy, options = {}) => {
            const localVarPath = `/v1/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }
            if (batchNumber !== undefined) {
                localVarQueryParameter['batch_number'] = batchNumber;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process Batch ID Labels
         * @summary Process Batch ID Labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch: async (batchId, processBatchRequestBody, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('processBatch', 'batchId', batchId);
            // verify required parameter 'processBatchRequestBody' is not null or undefined
            assertParamExists('processBatch', 'processBatchRequestBody', processBatchRequestBody);
            const localVarPath = `/v1/batches/{batch_id}/process/labels`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(processBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a shipment or rate from a batch
         * @summary Remove From Batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch: async (batchId, removeFromBatchRequestBody, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('removeFromBatch', 'batchId', batchId);
            // verify required parameter 'removeFromBatchRequestBody' is not null or undefined
            assertParamExists('removeFromBatch', 'removeFromBatchRequestBody', removeFromBatchRequestBody);
            const localVarPath = `/v1/batches/{batch_id}/remove`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(removeFromBatchRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Batch By Id
         * @summary Update Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch: async (batchId, options = {}) => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('updateBatch', 'batchId', batchId);
            const localVarPath = `/v1/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function (configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration);
    return {
        /**
         * Add a Shipment or Rate to a Batch
         * @summary Add to a Batch
         * @param {string} batchId Batch ID
         * @param {AddToBatchRequestBody} addToBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToBatch(batchId, addToBatchRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToBatch(batchId, addToBatchRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Batch
         * @summary Create A Batch
         * @param {CreateBatchRequestBody} createBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatch(createBatchRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(createBatchRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Batch By Id
         * @summary Delete Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatch(batchId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatch(batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Batch By External ID
         * @summary Get Batch By External ID
         * @param {string} externalBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchByExternalId(externalBatchId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchByExternalId(externalBatchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Batch By ID
         * @summary Get Batch By ID
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchById(batchId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchById(batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
         * @summary Get Batch Errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pagesize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchErrors(batchId, page, pagesize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchErrors(batchId, page, pagesize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Batches associated with your Shipengine account
         * @summary List Batches
         * @param {BatchStatus} [status]
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process Batch ID Labels
         * @summary Process Batch ID Labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processBatch(batchId, processBatchRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processBatch(batchId, processBatchRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a shipment or rate from a batch
         * @summary Remove From Batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromBatch(batchId, removeFromBatchRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFromBatch(batchId, removeFromBatchRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Batch By Id
         * @summary Update Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatch(batchId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatch(batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BatchesApiFp(configuration);
    return {
        /**
         * Add a Shipment or Rate to a Batch
         * @summary Add to a Batch
         * @param {string} batchId Batch ID
         * @param {AddToBatchRequestBody} addToBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBatch(batchId, addToBatchRequestBody, options) {
            return localVarFp.addToBatch(batchId, addToBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Batch
         * @summary Create A Batch
         * @param {CreateBatchRequestBody} createBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(createBatchRequestBody, options) {
            return localVarFp.createBatch(createBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Batch By Id
         * @summary Delete Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatch(batchId, options) {
            return localVarFp.deleteBatch(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Batch By External ID
         * @summary Get Batch By External ID
         * @param {string} externalBatchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchByExternalId(externalBatchId, options) {
            return localVarFp.getBatchByExternalId(externalBatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Batch By ID
         * @summary Get Batch By ID
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchById(batchId, options) {
            return localVarFp.getBatchById(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
         * @summary Get Batch Errors
         * @param {string} batchId Batch ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pagesize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchErrors(batchId, page, pagesize, options) {
            return localVarFp.listBatchErrors(batchId, page, pagesize, options).then((request) => request(axios, basePath));
        },
        /**
         * List Batches associated with your Shipengine account
         * @summary List Batches
         * @param {BatchStatus} [status]
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {string} [batchNumber] Batch Number
         * @param {BatchesSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options) {
            return localVarFp.listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Process Batch ID Labels
         * @summary Process Batch ID Labels
         * @param {string} batchId Batch ID
         * @param {ProcessBatchRequestBody} processBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBatch(batchId, processBatchRequestBody, options) {
            return localVarFp.processBatch(batchId, processBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a shipment or rate from a batch
         * @summary Remove From Batch
         * @param {string} batchId Batch ID
         * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromBatch(batchId, removeFromBatchRequestBody, options) {
            return localVarFp.removeFromBatch(batchId, removeFromBatchRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Batch By Id
         * @summary Update Batch By Id
         * @param {string} batchId Batch ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatch(batchId, options) {
            return localVarFp.updateBatch(batchId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Add a Shipment or Rate to a Batch
     * @summary Add to a Batch
     * @param {string} batchId Batch ID
     * @param {AddToBatchRequestBody} addToBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    addToBatch(batchId, addToBatchRequestBody, options) {
        return BatchesApiFp(this.configuration).addToBatch(batchId, addToBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a Batch
     * @summary Create A Batch
     * @param {CreateBatchRequestBody} createBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    createBatch(createBatchRequestBody, options) {
        return BatchesApiFp(this.configuration).createBatch(createBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete Batch By Id
     * @summary Delete Batch By Id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    deleteBatch(batchId, options) {
        return BatchesApiFp(this.configuration).deleteBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Batch By External ID
     * @summary Get Batch By External ID
     * @param {string} externalBatchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    getBatchByExternalId(externalBatchId, options) {
        return BatchesApiFp(this.configuration).getBatchByExternalId(externalBatchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Batch By ID
     * @summary Get Batch By ID
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    getBatchById(batchId, options) {
        return BatchesApiFp(this.configuration).getBatchById(batchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Error handling in batches are handled differently than in a single synchronous request. You must retrieve the status of your batch by [getting a batch](https://www.shipengine.com/docs/reference/get-batch-by-id/) and getting an overview of the statuses or you can list errors directly here below to get detailed information about the errors.
     * @summary Get Batch Errors
     * @param {string} batchId Batch ID
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pagesize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    listBatchErrors(batchId, page, pagesize, options) {
        return BatchesApiFp(this.configuration).listBatchErrors(batchId, page, pagesize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Batches associated with your Shipengine account
     * @summary List Batches
     * @param {BatchStatus} [status]
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {string} [batchNumber] Batch Number
     * @param {BatchesSortBy} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options) {
        return BatchesApiFp(this.configuration).listBatches(status, page, pageSize, sortDir, batchNumber, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Process Batch ID Labels
     * @summary Process Batch ID Labels
     * @param {string} batchId Batch ID
     * @param {ProcessBatchRequestBody} processBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    processBatch(batchId, processBatchRequestBody, options) {
        return BatchesApiFp(this.configuration).processBatch(batchId, processBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove a shipment or rate from a batch
     * @summary Remove From Batch
     * @param {string} batchId Batch ID
     * @param {RemoveFromBatchRequestBody} removeFromBatchRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    removeFromBatch(batchId, removeFromBatchRequestBody, options) {
        return BatchesApiFp(this.configuration).removeFromBatch(batchId, removeFromBatchRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Batch By Id
     * @summary Update Batch By Id
     * @param {string} batchId Batch ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    updateBatch(batchId, options) {
        return BatchesApiFp(this.configuration).updateBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CarrierAccountsApi - axios parameter creator
 * @export
 */
export const CarrierAccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Connect a carrier account
         * @summary Connect a carrier account
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCarrier: async (carrierName, connectCarrierRequestBody, options = {}) => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('connectCarrier', 'carrierName', carrierName);
            // verify required parameter 'connectCarrierRequestBody' is not null or undefined
            assertParamExists('connectCarrier', 'connectCarrierRequestBody', connectCarrierRequestBody);
            const localVarPath = `/v1/connections/carriers/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(connectCarrierRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect a carrier
         * @summary Disconnect a carrier
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectCarrier: async (carrierName, carrierId, options = {}) => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('disconnectCarrier', 'carrierName', carrierName);
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('disconnectCarrier', 'carrierId', carrierId);
            const localVarPath = `/v1/connections/carriers/{carrier_name}/{carrier_id}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get carrier settings
         * @summary Get carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierSettings: async (carrierName, carrierId, options = {}) => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getCarrierSettings', 'carrierName', carrierName);
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('getCarrierSettings', 'carrierId', carrierId);
            const localVarPath = `/v1/connections/carriers/{carrier_name}/{carrier_id}/settings`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update carrier settings
         * @summary Update carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCarrierSettings: async (carrierName, carrierId, updateCarrierSettingsRequestBody, options = {}) => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('updateCarrierSettings', 'carrierName', carrierName);
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('updateCarrierSettings', 'carrierId', carrierId);
            // verify required parameter 'updateCarrierSettingsRequestBody' is not null or undefined
            assertParamExists('updateCarrierSettings', 'updateCarrierSettingsRequestBody', updateCarrierSettingsRequestBody);
            const localVarPath = `/v1/connections/carriers/{carrier_name}/{carrier_id}/settings`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateCarrierSettingsRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CarrierAccountsApi - functional programming interface
 * @export
 */
export const CarrierAccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CarrierAccountsApiAxiosParamCreator(configuration);
    return {
        /**
         * Connect a carrier account
         * @summary Connect a carrier account
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectCarrier(carrierName, connectCarrierRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectCarrier(carrierName, connectCarrierRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disconnect a carrier
         * @summary Disconnect a carrier
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectCarrier(carrierName, carrierId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectCarrier(carrierName, carrierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get carrier settings
         * @summary Get carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarrierSettings(carrierName, carrierId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarrierSettings(carrierName, carrierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update carrier settings
         * @summary Update carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CarrierAccountsApi - factory interface
 * @export
 */
export const CarrierAccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CarrierAccountsApiFp(configuration);
    return {
        /**
         * Connect a carrier account
         * @summary Connect a carrier account
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCarrier(carrierName, connectCarrierRequestBody, options) {
            return localVarFp.connectCarrier(carrierName, connectCarrierRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect a carrier
         * @summary Disconnect a carrier
         * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectCarrier(carrierName, carrierId, options) {
            return localVarFp.disconnectCarrier(carrierName, carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get carrier settings
         * @summary Get carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierSettings(carrierName, carrierId, options) {
            return localVarFp.getCarrierSettings(carrierName, carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update carrier settings
         * @summary Update carrier settings
         * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
         * @param {string} carrierId Carrier ID
         * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options) {
            return localVarFp.updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CarrierAccountsApi - object-oriented interface
 * @export
 * @class CarrierAccountsApi
 * @extends {BaseAPI}
 */
export class CarrierAccountsApi extends BaseAPI {
    /**
     * Connect a carrier account
     * @summary Connect a carrier account
     * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {ConnectCarrierRequestBody} connectCarrierRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    connectCarrier(carrierName, connectCarrierRequestBody, options) {
        return CarrierAccountsApiFp(this.configuration).connectCarrier(carrierName, connectCarrierRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disconnect a carrier
     * @summary Disconnect a carrier
     * @param {CarrierName} carrierName The carrier name, such as &#x60;stamps_com&#x60;, &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    disconnectCarrier(carrierName, carrierId, options) {
        return CarrierAccountsApiFp(this.configuration).disconnectCarrier(carrierName, carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get carrier settings
     * @summary Get carrier settings
     * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    getCarrierSettings(carrierName, carrierId, options) {
        return CarrierAccountsApiFp(this.configuration).getCarrierSettings(carrierName, carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update carrier settings
     * @summary Update carrier settings
     * @param {CarrierNameWithSettings} carrierName The carrier name, such as &#x60;ups&#x60;, &#x60;fedex&#x60;, or &#x60;dhl_express&#x60;.
     * @param {string} carrierId Carrier ID
     * @param {UpdateCarrierSettingsRequestBody} updateCarrierSettingsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarrierAccountsApi
     */
    updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options) {
        return CarrierAccountsApiFp(this.configuration).updateCarrierSettings(carrierName, carrierId, updateCarrierSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CarriersApi - axios parameter creator
 * @export
 */
export const CarriersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Funds To A Carrier
         * @summary Add Funds To Carrier
         * @param {string} carrierId Carrier ID
         * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToCarrier: async (carrierId, addFundsToCarrierRequestBody, options = {}) => {
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('addFundsToCarrier', 'carrierId', carrierId);
            // verify required parameter 'addFundsToCarrierRequestBody' is not null or undefined
            assertParamExists('addFundsToCarrier', 'addFundsToCarrierRequestBody', addFundsToCarrierRequestBody);
            const localVarPath = `/v1/carriers/{carrier_id}/add_funds`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addFundsToCarrierRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrive carrier info by ID
         * @summary Get Carrier By ID
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierById: async (carrierId, options = {}) => {
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('getCarrierById', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the options available for the carrier
         * @summary Get Carrier Options
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierOptions: async (carrierId, options = {}) => {
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('getCarrierOptions', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}/options`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the package types associated with the carrier
         * @summary List Carrier Package Types
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierPackageTypes: async (carrierId, options = {}) => {
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('listCarrierPackageTypes', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}/packages`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the services associated with the carrier ID
         * @summary List Carrier Services
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierServices: async (carrierId, options = {}) => {
            // verify required parameter 'carrierId' is not null or undefined
            assertParamExists('listCarrierServices', 'carrierId', carrierId);
            const localVarPath = `/v1/carriers/{carrier_id}/services`
                .replace(`{${"carrier_id"}}`, encodeURIComponent(String(carrierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all carriers that have been added to this account
         * @summary List Carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarriers: async (options = {}) => {
            const localVarPath = `/v1/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CarriersApi - functional programming interface
 * @export
 */
export const CarriersApiFp = function (configuration) {
    const localVarAxiosParamCreator = CarriersApiAxiosParamCreator(configuration);
    return {
        /**
         * Add Funds To A Carrier
         * @summary Add Funds To Carrier
         * @param {string} carrierId Carrier ID
         * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrive carrier info by ID
         * @summary Get Carrier By ID
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarrierById(carrierId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarrierById(carrierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the options available for the carrier
         * @summary Get Carrier Options
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarrierOptions(carrierId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarrierOptions(carrierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the package types associated with the carrier
         * @summary List Carrier Package Types
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCarrierPackageTypes(carrierId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCarrierPackageTypes(carrierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the services associated with the carrier ID
         * @summary List Carrier Services
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCarrierServices(carrierId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCarrierServices(carrierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all carriers that have been added to this account
         * @summary List Carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCarriers(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCarriers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CarriersApi - factory interface
 * @export
 */
export const CarriersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CarriersApiFp(configuration);
    return {
        /**
         * Add Funds To A Carrier
         * @summary Add Funds To Carrier
         * @param {string} carrierId Carrier ID
         * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options) {
            return localVarFp.addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrive carrier info by ID
         * @summary Get Carrier By ID
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierById(carrierId, options) {
            return localVarFp.getCarrierById(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the options available for the carrier
         * @summary Get Carrier Options
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarrierOptions(carrierId, options) {
            return localVarFp.getCarrierOptions(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the package types associated with the carrier
         * @summary List Carrier Package Types
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierPackageTypes(carrierId, options) {
            return localVarFp.listCarrierPackageTypes(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the services associated with the carrier ID
         * @summary List Carrier Services
         * @param {string} carrierId Carrier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarrierServices(carrierId, options) {
            return localVarFp.listCarrierServices(carrierId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all carriers that have been added to this account
         * @summary List Carriers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCarriers(options) {
            return localVarFp.listCarriers(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CarriersApi - object-oriented interface
 * @export
 * @class CarriersApi
 * @extends {BaseAPI}
 */
export class CarriersApi extends BaseAPI {
    /**
     * Add Funds To A Carrier
     * @summary Add Funds To Carrier
     * @param {string} carrierId Carrier ID
     * @param {AddFundsToCarrierRequestBody} addFundsToCarrierRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options) {
        return CarriersApiFp(this.configuration).addFundsToCarrier(carrierId, addFundsToCarrierRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrive carrier info by ID
     * @summary Get Carrier By ID
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    getCarrierById(carrierId, options) {
        return CarriersApiFp(this.configuration).getCarrierById(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of the options available for the carrier
     * @summary Get Carrier Options
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    getCarrierOptions(carrierId, options) {
        return CarriersApiFp(this.configuration).getCarrierOptions(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the package types associated with the carrier
     * @summary List Carrier Package Types
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    listCarrierPackageTypes(carrierId, options) {
        return CarriersApiFp(this.configuration).listCarrierPackageTypes(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the services associated with the carrier ID
     * @summary List Carrier Services
     * @param {string} carrierId Carrier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    listCarrierServices(carrierId, options) {
        return CarriersApiFp(this.configuration).listCarrierServices(carrierId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all carriers that have been added to this account
     * @summary List Carriers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    listCarriers(options) {
        return CarriersApiFp(this.configuration).listCarriers(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DownloadsApi - axios parameter creator
 * @export
 */
export const DownloadsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get File
         * @summary Download File
         * @param {string} subdir
         * @param {string} filename
         * @param {string} dir
         * @param {string} [download]
         * @param {number} [rotation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (subdir, filename, dir, download, rotation, options = {}) => {
            // verify required parameter 'subdir' is not null or undefined
            assertParamExists('downloadFile', 'subdir', subdir);
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('downloadFile', 'filename', filename);
            // verify required parameter 'dir' is not null or undefined
            assertParamExists('downloadFile', 'dir', dir);
            const localVarPath = `/v1/downloads/{dir}/{subdir}/{filename}`
                .replace(`{${"subdir"}}`, encodeURIComponent(String(subdir)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)))
                .replace(`{${"dir"}}`, encodeURIComponent(String(dir)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }
            if (rotation !== undefined) {
                localVarQueryParameter['rotation'] = rotation;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DownloadsApi - functional programming interface
 * @export
 */
export const DownloadsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DownloadsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get File
         * @summary Download File
         * @param {string} subdir
         * @param {string} filename
         * @param {string} dir
         * @param {string} [download]
         * @param {number} [rotation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(subdir, filename, dir, download, rotation, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(subdir, filename, dir, download, rotation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DownloadsApi - factory interface
 * @export
 */
export const DownloadsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DownloadsApiFp(configuration);
    return {
        /**
         * Get File
         * @summary Download File
         * @param {string} subdir
         * @param {string} filename
         * @param {string} dir
         * @param {string} [download]
         * @param {number} [rotation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(subdir, filename, dir, download, rotation, options) {
            return localVarFp.downloadFile(subdir, filename, dir, download, rotation, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DownloadsApi - object-oriented interface
 * @export
 * @class DownloadsApi
 * @extends {BaseAPI}
 */
export class DownloadsApi extends BaseAPI {
    /**
     * Get File
     * @summary Download File
     * @param {string} subdir
     * @param {string} filename
     * @param {string} dir
     * @param {string} [download]
     * @param {number} [rotation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadsApi
     */
    downloadFile(subdir, filename, dir, download, rotation, options) {
        return DownloadsApiFp(this.configuration).downloadFile(subdir, filename, dir, download, rotation, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * InsuranceApi - axios parameter creator
 * @export
 */
export const InsuranceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
         * @summary Add Funds To Insurance
         * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToInsurance: async (addFundsToInsuranceRequestBody, options = {}) => {
            // verify required parameter 'addFundsToInsuranceRequestBody' is not null or undefined
            assertParamExists('addFundsToInsurance', 'addFundsToInsuranceRequestBody', addFundsToInsuranceRequestBody);
            const localVarPath = `/v1/insurance/shipsurance/add_funds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addFundsToInsuranceRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect a Shipsurance Account
         * @summary Connect a Shipsurance Account
         * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectInsurer: async (connectInsurerRequestBody, options = {}) => {
            // verify required parameter 'connectInsurerRequestBody' is not null or undefined
            assertParamExists('connectInsurer', 'connectInsurerRequestBody', connectInsurerRequestBody);
            const localVarPath = `/v1/connections/insurance/shipsurance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(connectInsurerRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect a Shipsurance Account
         * @summary Disconnect a Shipsurance Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectInsurer: async (options = {}) => {
            const localVarPath = `/v1/connections/insurance/shipsurance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the balance of your Shipsurance account.
         * @summary Get Insurance Funds Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsuranceBalance: async (options = {}) => {
            const localVarPath = `/v1/insurance/shipsurance/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InsuranceApi - functional programming interface
 * @export
 */
export const InsuranceApiFp = function (configuration) {
    const localVarAxiosParamCreator = InsuranceApiAxiosParamCreator(configuration);
    return {
        /**
         * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
         * @summary Add Funds To Insurance
         * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFundsToInsurance(addFundsToInsuranceRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFundsToInsurance(addFundsToInsuranceRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect a Shipsurance Account
         * @summary Connect a Shipsurance Account
         * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectInsurer(connectInsurerRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectInsurer(connectInsurerRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disconnect a Shipsurance Account
         * @summary Disconnect a Shipsurance Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectInsurer(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectInsurer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the balance of your Shipsurance account.
         * @summary Get Insurance Funds Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInsuranceBalance(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInsuranceBalance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * InsuranceApi - factory interface
 * @export
 */
export const InsuranceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = InsuranceApiFp(configuration);
    return {
        /**
         * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
         * @summary Add Funds To Insurance
         * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFundsToInsurance(addFundsToInsuranceRequestBody, options) {
            return localVarFp.addFundsToInsurance(addFundsToInsuranceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect a Shipsurance Account
         * @summary Connect a Shipsurance Account
         * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectInsurer(connectInsurerRequestBody, options) {
            return localVarFp.connectInsurer(connectInsurerRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect a Shipsurance Account
         * @summary Disconnect a Shipsurance Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectInsurer(options) {
            return localVarFp.disconnectInsurer(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the balance of your Shipsurance account.
         * @summary Get Insurance Funds Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsuranceBalance(options) {
            return localVarFp.getInsuranceBalance(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InsuranceApi - object-oriented interface
 * @export
 * @class InsuranceApi
 * @extends {BaseAPI}
 */
export class InsuranceApi extends BaseAPI {
    /**
     * You may need to auto fund your account from time to time. For example, if you don\'t normally ship items over $100, and may want to add funds to insurance rather than keeping the account funded.
     * @summary Add Funds To Insurance
     * @param {AddFundsToInsuranceRequestBody} addFundsToInsuranceRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    addFundsToInsurance(addFundsToInsuranceRequestBody, options) {
        return InsuranceApiFp(this.configuration).addFundsToInsurance(addFundsToInsuranceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Connect a Shipsurance Account
     * @summary Connect a Shipsurance Account
     * @param {ConnectInsurerRequestBody} connectInsurerRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    connectInsurer(connectInsurerRequestBody, options) {
        return InsuranceApiFp(this.configuration).connectInsurer(connectInsurerRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disconnect a Shipsurance Account
     * @summary Disconnect a Shipsurance Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    disconnectInsurer(options) {
        return InsuranceApiFp(this.configuration).disconnectInsurer(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the balance of your Shipsurance account.
     * @summary Get Insurance Funds Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    getInsuranceBalance(options) {
        return InsuranceApiFp(this.configuration).getInsuranceBalance(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {CreateLabelRequestBody} createLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel: async (createLabelRequestBody, options = {}) => {
            // verify required parameter 'createLabelRequestBody' is not null or undefined
            assertParamExists('createLabel', 'createLabelRequestBody', createLabelRequestBody);
            const localVarPath = `/v1/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createLabelRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromRate: async (rateId, createLabelFromRateRequestBody, options = {}) => {
            // verify required parameter 'rateId' is not null or undefined
            assertParamExists('createLabelFromRate', 'rateId', rateId);
            // verify required parameter 'createLabelFromRateRequestBody' is not null or undefined
            assertParamExists('createLabelFromRate', 'createLabelFromRateRequestBody', createLabelFromRateRequestBody);
            const localVarPath = `/v1/labels/rates/{rate_id}`
                .replace(`{${"rate_id"}}`, encodeURIComponent(String(rateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createLabelFromRateRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info.
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromShipment: async (shipmentId, createLabelFromShipmentRequestBody, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('createLabelFromShipment', 'shipmentId', shipmentId);
            // verify required parameter 'createLabelFromShipmentRequestBody' is not null or undefined
            assertParamExists('createLabelFromShipment', 'createLabelFromShipmentRequestBody', createLabelFromShipmentRequestBody);
            const localVarPath = `/v1/labels/shipment/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createLabelFromShipmentRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel: async (labelId, createReturnLabelRequestBody, options = {}) => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('createReturnLabel', 'labelId', labelId);
            // verify required parameter 'createReturnLabelRequestBody' is not null or undefined
            assertParamExists('createReturnLabel', 'createReturnLabelRequestBody', createReturnLabelRequestBody);
            const localVarPath = `/v1/labels/{label_id}/return`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createReturnLabelRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a label by using the external shipment id that was used during label creation
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelByExternalShipmentId: async (externalShipmentId, labelDownloadType, options = {}) => {
            // verify required parameter 'externalShipmentId' is not null or undefined
            assertParamExists('getLabelByExternalShipmentId', 'externalShipmentId', externalShipmentId);
            const localVarPath = `/v1/labels/external_shipment_id/{external_shipment_id}`
                .replace(`{${"external_shipment_id"}}`, encodeURIComponent(String(externalShipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (labelDownloadType !== undefined) {
                localVarQueryParameter['label_download_type'] = labelDownloadType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById: async (labelId, labelDownloadType, options = {}) => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('getLabelById', 'labelId', labelId);
            const localVarPath = `/v1/labels/{label_id}`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (labelDownloadType !== undefined) {
                localVarQueryParameter['label_download_type'] = labelDownloadType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLogFromLabel: async (labelId, options = {}) => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('getTrackingLogFromLabel', 'labelId', labelId);
            const localVarPath = `/v1/labels/{label_id}/track`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels: async (labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options = {}) => {
            const localVarPath = `/v1/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (labelStatus !== undefined) {
                localVarQueryParameter['label_status'] = labelStatus;
            }
            if (serviceCode !== undefined) {
                localVarQueryParameter['service_code'] = serviceCode;
            }
            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }
            if (rateId !== undefined) {
                localVarQueryParameter['rate_id'] = rateId;
            }
            if (shipmentId !== undefined) {
                localVarQueryParameter['shipment_id'] = shipmentId;
            }
            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: async (labelId, options = {}) => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('voidLabel', 'labelId', labelId);
            const localVarPath = `/v1/labels/{label_id}/void`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function (configuration) {
    const localVarAxiosParamCreator = LabelsApiAxiosParamCreator(configuration);
    return {
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {CreateLabelRequestBody} createLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLabel(createLabelRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLabel(createLabelRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLabelFromRate(rateId, createLabelFromRateRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLabelFromRate(rateId, createLabelFromRateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info.
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReturnLabel(labelId, createReturnLabelRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReturnLabel(labelId, createReturnLabelRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find a label by using the external shipment id that was used during label creation
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabelById(labelId, labelDownloadType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabelById(labelId, labelDownloadType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackingLogFromLabel(labelId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackingLogFromLabel(labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidLabel(labelId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidLabel(labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LabelsApiFp(configuration);
    return {
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {CreateLabelRequestBody} createLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel(createLabelRequestBody, options) {
            return localVarFp.createLabel(createLabelRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromRate(rateId, createLabelFromRateRequestBody, options) {
            return localVarFp.createLabelFromRate(rateId, createLabelFromRateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info.
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options) {
            return localVarFp.createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel(labelId, createReturnLabelRequestBody, options) {
            return localVarFp.createReturnLabel(labelId, createReturnLabelRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a label by using the external shipment id that was used during label creation
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options) {
            return localVarFp.getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById(labelId, labelDownloadType, options) {
            return localVarFp.getLabelById(labelId, labelDownloadType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLogFromLabel(labelId, options) {
            return localVarFp.getTrackingLogFromLabel(labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options) {
            return localVarFp.listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(labelId, options) {
            return localVarFp.voidLabel(labelId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
export class LabelsApi extends BaseAPI {
    /**
     * Purchase and print a label for shipment
     * @summary Purchase Label
     * @param {CreateLabelRequestBody} createLabelRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createLabel(createLabelRequestBody, options) {
        return LabelsApiFp(this.configuration).createLabel(createLabelRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly.
     * @summary Purchase Label with Rate ID
     * @param {string} rateId Rate ID
     * @param {CreateLabelFromRateRequestBody} createLabelFromRateRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createLabelFromRate(rateId, createLabelFromRateRequestBody, options) {
        return LabelsApiFp(this.configuration).createLabelFromRate(rateId, createLabelFromRateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Purchase a label using a shipment ID that has already been created with the desired address and package info.
     * @summary Purchase Label with Shipment ID
     * @param {string} shipmentId Shipment ID
     * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options) {
        return LabelsApiFp(this.configuration).createLabelFromShipment(shipmentId, createLabelFromShipmentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a return label
     * @summary Create a return label
     * @param {string} labelId Label ID
     * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    createReturnLabel(labelId, createReturnLabelRequestBody, options) {
        return LabelsApiFp(this.configuration).createReturnLabel(labelId, createReturnLabelRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Find a label by using the external shipment id that was used during label creation
     * @summary Get Label By External Shipment ID
     * @param {string} externalShipmentId
     * @param {LabelDownloadType} [labelDownloadType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options) {
        return LabelsApiFp(this.configuration).getLabelByExternalShipmentId(externalShipmentId, labelDownloadType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve information for individual labels.
     * @summary Get Label By ID
     * @param {string} labelId Label ID
     * @param {LabelDownloadType} [labelDownloadType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getLabelById(labelId, labelDownloadType, options) {
        return LabelsApiFp(this.configuration).getLabelById(labelId, labelDownloadType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the label\'s tracking information
     * @summary Get Label Tracking Information
     * @param {string} labelId Label ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getTrackingLogFromLabel(labelId, options) {
        return LabelsApiFp(this.configuration).getTrackingLogFromLabel(labelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id`
     * @summary List labels
     * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
     * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
     * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
     * @param {string} [trackingNumber] Only return labels with a specific tracking number
     * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
     * @param {string} [rateId] Rate ID
     * @param {string} [shipmentId] Shipment ID
     * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
     * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
     * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {ListLabelsSortByEnum} [sortBy] Controls which field the query is sorted by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options) {
        return LabelsApiFp(this.configuration).listLabels(labelStatus, serviceCode, carrierId, trackingNumber, batchId, rateId, shipmentId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, sortDir, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Void a label by ID to get a refund.
     * @summary Void a Label By ID
     * @param {string} labelId Label ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    voidLabel(labelId, options) {
        return LabelsApiFp(this.configuration).voidLabel(labelId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const ListLabelsSortByEnum = {
    ModifiedAt: 'modified_at',
    CreatedAt: 'created_at'
};
/**
 * ManifestsApi - axios parameter creator
 * @export
 */
export const ManifestsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
         * @summary Create Manifest
         * @param {CreateManifestRequestBody} createManifestRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManifest: async (createManifestRequestBody, options = {}) => {
            // verify required parameter 'createManifestRequestBody' is not null or undefined
            assertParamExists('createManifest', 'createManifestRequestBody', createManifestRequestBody);
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createManifestRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Manifest By Id
         * @summary Get Manifest By Id
         * @param {string} manifestId The Manifest Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestById: async (manifestId, options = {}) => {
            // verify required parameter 'manifestId' is not null or undefined
            assertParamExists('getManifestById', 'manifestId', manifestId);
            const localVarPath = `/v1/manifests/{manifest_id}`
                .replace(`{${"manifest_id"}}`, encodeURIComponent(String(manifestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Manifest Request By Id
         * @summary Get Manifest Request By Id
         * @param {string} manifestRequestId The Manifest Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestRequestById: async (manifestRequestId, options = {}) => {
            // verify required parameter 'manifestRequestId' is not null or undefined
            assertParamExists('getManifestRequestById', 'manifestRequestId', manifestRequestId);
            const localVarPath = `/v1/manifests/requests/{manifest_request_id}`
                .replace(`{${"manifest_request_id"}}`, encodeURIComponent(String(manifestRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
         * @summary List Manifests
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [shipDateStart] ship date start range
         * @param {string} [shipDateEnd] ship date end range
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [carrierId] Carrier ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {Array<string>} [labelIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManifests: async (warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options = {}) => {
            const localVarPath = `/v1/manifests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }
            if (shipDateStart !== undefined) {
                localVarQueryParameter['ship_date_start'] = (shipDateStart instanceof Date) ?
                    shipDateStart.toISOString() :
                    shipDateStart;
            }
            if (shipDateEnd !== undefined) {
                localVarQueryParameter['ship_date_end'] = (shipDateEnd instanceof Date) ?
                    shipDateEnd.toISOString() :
                    shipDateEnd;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (labelIds) {
                localVarQueryParameter['label_ids'] = labelIds;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ManifestsApi - functional programming interface
 * @export
 */
export const ManifestsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ManifestsApiAxiosParamCreator(configuration);
    return {
        /**
         * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
         * @summary Create Manifest
         * @param {CreateManifestRequestBody} createManifestRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManifest(createManifestRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManifest(createManifestRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Manifest By Id
         * @summary Get Manifest By Id
         * @param {string} manifestId The Manifest Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManifestById(manifestId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManifestById(manifestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Manifest Request By Id
         * @summary Get Manifest Request By Id
         * @param {string} manifestRequestId The Manifest Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManifestRequestById(manifestRequestId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManifestRequestById(manifestRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
         * @summary List Manifests
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [shipDateStart] ship date start range
         * @param {string} [shipDateEnd] ship date end range
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [carrierId] Carrier ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {Array<string>} [labelIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ManifestsApi - factory interface
 * @export
 */
export const ManifestsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ManifestsApiFp(configuration);
    return {
        /**
         * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
         * @summary Create Manifest
         * @param {CreateManifestRequestBody} createManifestRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManifest(createManifestRequestBody, options) {
            return localVarFp.createManifest(createManifestRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Manifest By Id
         * @summary Get Manifest By Id
         * @param {string} manifestId The Manifest Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestById(manifestId, options) {
            return localVarFp.getManifestById(manifestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Manifest Request By Id
         * @summary Get Manifest Request By Id
         * @param {string} manifestRequestId The Manifest Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifestRequestById(manifestRequestId, options) {
            return localVarFp.getManifestRequestById(manifestRequestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
         * @summary List Manifests
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [shipDateStart] ship date start range
         * @param {string} [shipDateEnd] ship date end range
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [carrierId] Carrier ID
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {Array<string>} [labelIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options) {
            return localVarFp.listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ManifestsApi - object-oriented interface
 * @export
 * @class ManifestsApi
 * @extends {BaseAPI}
 */
export class ManifestsApi extends BaseAPI {
    /**
     * Each ShipEngine manifest is created for a specific warehouse, so you\'ll need to provide the warehouse_id rather than the ship_from address. You can create a warehouse for each location that you want to create manifests for.
     * @summary Create Manifest
     * @param {CreateManifestRequestBody} createManifestRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    createManifest(createManifestRequestBody, options) {
        return ManifestsApiFp(this.configuration).createManifest(createManifestRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Manifest By Id
     * @summary Get Manifest By Id
     * @param {string} manifestId The Manifest Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    getManifestById(manifestId, options) {
        return ManifestsApiFp(this.configuration).getManifestById(manifestId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Manifest Request By Id
     * @summary Get Manifest Request By Id
     * @param {string} manifestRequestId The Manifest Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    getManifestRequestById(manifestRequestId, options) {
        return ManifestsApiFp(this.configuration).getManifestRequestById(manifestRequestId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Similar to querying shipments, we allow you to query manifests since there will likely be a large number over a long period of time.
     * @summary List Manifests
     * @param {string} [warehouseId] Warehouse ID
     * @param {string} [shipDateStart] ship date start range
     * @param {string} [shipDateEnd] ship date end range
     * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
     * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
     * @param {string} [carrierId] Carrier ID
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {Array<string>} [labelIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options) {
        return ManifestsApiFp(this.configuration).listManifests(warehouseId, shipDateStart, shipDateEnd, createdAtStart, createdAtEnd, carrierId, page, pageSize, labelIds, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PackagePickupsApi - axios parameter creator
 * @export
 */
export const PackagePickupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a previously-scheduled pickup by ID
         * @summary Delete a Scheduled Pickup
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledPickup: async (pickupId, options = {}) => {
            // verify required parameter 'pickupId' is not null or undefined
            assertParamExists('deleteScheduledPickup', 'pickupId', pickupId);
            const localVarPath = `/v1/pickups/{pickup_id}`
                .replace(`{${"pickup_id"}}`, encodeURIComponent(String(pickupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Pickup By ID
         * @summary Get Pickup By ID
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickupById: async (pickupId, options = {}) => {
            // verify required parameter 'pickupId' is not null or undefined
            assertParamExists('getPickupById', 'pickupId', pickupId);
            const localVarPath = `/v1/pickups/{pickup_id}`
                .replace(`{${"pickup_id"}}`, encodeURIComponent(String(pickupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all pickups that have been scheduled for this carrier
         * @summary List Scheduled Pickups
         * @param {string} [carrierId] Carrier ID
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPickups: async (carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options = {}) => {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }
            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a package pickup with a carrier
         * @summary Schedule a Pickup
         * @param {SchedulePickupRequestBody} schedulePickupRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: async (schedulePickupRequestBody, options = {}) => {
            // verify required parameter 'schedulePickupRequestBody' is not null or undefined
            assertParamExists('schedulePickup', 'schedulePickupRequestBody', schedulePickupRequestBody);
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(schedulePickupRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PackagePickupsApi - functional programming interface
 * @export
 */
export const PackagePickupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PackagePickupsApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete a previously-scheduled pickup by ID
         * @summary Delete a Scheduled Pickup
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledPickup(pickupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledPickup(pickupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Pickup By ID
         * @summary Get Pickup By ID
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPickupById(pickupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPickupById(pickupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all pickups that have been scheduled for this carrier
         * @summary List Scheduled Pickups
         * @param {string} [carrierId] Carrier ID
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule a package pickup with a carrier
         * @summary Schedule a Pickup
         * @param {SchedulePickupRequestBody} schedulePickupRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePickup(schedulePickupRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePickup(schedulePickupRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PackagePickupsApi - factory interface
 * @export
 */
export const PackagePickupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PackagePickupsApiFp(configuration);
    return {
        /**
         * Delete a previously-scheduled pickup by ID
         * @summary Delete a Scheduled Pickup
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledPickup(pickupId, options) {
            return localVarFp.deleteScheduledPickup(pickupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Pickup By ID
         * @summary Get Pickup By ID
         * @param {string} pickupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickupById(pickupId, options) {
            return localVarFp.getPickupById(pickupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all pickups that have been scheduled for this carrier
         * @summary List Scheduled Pickups
         * @param {string} [carrierId] Carrier ID
         * @param {string} [warehouseId] Warehouse ID
         * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options) {
            return localVarFp.listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a package pickup with a carrier
         * @summary Schedule a Pickup
         * @param {SchedulePickupRequestBody} schedulePickupRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(schedulePickupRequestBody, options) {
            return localVarFp.schedulePickup(schedulePickupRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PackagePickupsApi - object-oriented interface
 * @export
 * @class PackagePickupsApi
 * @extends {BaseAPI}
 */
export class PackagePickupsApi extends BaseAPI {
    /**
     * Delete a previously-scheduled pickup by ID
     * @summary Delete a Scheduled Pickup
     * @param {string} pickupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    deleteScheduledPickup(pickupId, options) {
        return PackagePickupsApiFp(this.configuration).deleteScheduledPickup(pickupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Pickup By ID
     * @summary Get Pickup By ID
     * @param {string} pickupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    getPickupById(pickupId, options) {
        return PackagePickupsApiFp(this.configuration).getPickupById(pickupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all pickups that have been scheduled for this carrier
     * @summary List Scheduled Pickups
     * @param {string} [carrierId] Carrier ID
     * @param {string} [warehouseId] Warehouse ID
     * @param {string} [createdAtStart] Only return scheduled pickups that were created on or after a specific date/time
     * @param {string} [createdAtEnd] Only return scheduled pickups that were created on or before a specific date/time
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options) {
        return PackagePickupsApiFp(this.configuration).listScheduledPickups(carrierId, warehouseId, createdAtStart, createdAtEnd, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Schedule a package pickup with a carrier
     * @summary Schedule a Pickup
     * @param {SchedulePickupRequestBody} schedulePickupRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagePickupsApi
     */
    schedulePickup(schedulePickupRequestBody, options) {
        return PackagePickupsApiFp(this.configuration).schedulePickup(schedulePickupRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PackageTypesApi - axios parameter creator
 * @export
 */
export const PackageTypesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a custom package type to better assist in getting accurate rate estimates
         * @summary Create Custom Package Type
         * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageType: async (createPackageTypeRequestBody, options = {}) => {
            // verify required parameter 'createPackageTypeRequestBody' is not null or undefined
            assertParamExists('createPackageType', 'createPackageTypeRequestBody', createPackageTypeRequestBody);
            const localVarPath = `/v1/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createPackageTypeRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a custom package using the ID
         * @summary Delete A Custom Package By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageType: async (packageId, options = {}) => {
            // verify required parameter 'packageId' is not null or undefined
            assertParamExists('deletePackageType', 'packageId', packageId);
            const localVarPath = `/v1/packages/{package_id}`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Custom Package Type by ID
         * @summary Get Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageTypeById: async (packageId, options = {}) => {
            // verify required parameter 'packageId' is not null or undefined
            assertParamExists('getPackageTypeById', 'packageId', packageId);
            const localVarPath = `/v1/packages/{package_id}`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the custom package types associated with the account
         * @summary List Custom Package Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageTypes: async (options = {}) => {
            const localVarPath = `/v1/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the custom package type object by ID
         * @summary Update Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageType: async (packageId, updatePackageTypeRequestBody, options = {}) => {
            // verify required parameter 'packageId' is not null or undefined
            assertParamExists('updatePackageType', 'packageId', packageId);
            // verify required parameter 'updatePackageTypeRequestBody' is not null or undefined
            assertParamExists('updatePackageType', 'updatePackageTypeRequestBody', updatePackageTypeRequestBody);
            const localVarPath = `/v1/packages/{package_id}`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updatePackageTypeRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PackageTypesApi - functional programming interface
 * @export
 */
export const PackageTypesApiFp = function (configuration) {
    const localVarAxiosParamCreator = PackageTypesApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a custom package type to better assist in getting accurate rate estimates
         * @summary Create Custom Package Type
         * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPackageType(createPackageTypeRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPackageType(createPackageTypeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a custom package using the ID
         * @summary Delete A Custom Package By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePackageType(packageId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePackageType(packageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Custom Package Type by ID
         * @summary Get Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackageTypeById(packageId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPackageTypeById(packageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the custom package types associated with the account
         * @summary List Custom Package Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackageTypes(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackageTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the custom package type object by ID
         * @summary Update Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePackageType(packageId, updatePackageTypeRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePackageType(packageId, updatePackageTypeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PackageTypesApi - factory interface
 * @export
 */
export const PackageTypesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PackageTypesApiFp(configuration);
    return {
        /**
         * Create a custom package type to better assist in getting accurate rate estimates
         * @summary Create Custom Package Type
         * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPackageType(createPackageTypeRequestBody, options) {
            return localVarFp.createPackageType(createPackageTypeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom package using the ID
         * @summary Delete A Custom Package By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackageType(packageId, options) {
            return localVarFp.deletePackageType(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Custom Package Type by ID
         * @summary Get Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageTypeById(packageId, options) {
            return localVarFp.getPackageTypeById(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the custom package types associated with the account
         * @summary List Custom Package Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageTypes(options) {
            return localVarFp.listPackageTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the custom package type object by ID
         * @summary Update Custom Package Type By ID
         * @param {string} packageId Package ID
         * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackageType(packageId, updatePackageTypeRequestBody, options) {
            return localVarFp.updatePackageType(packageId, updatePackageTypeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PackageTypesApi - object-oriented interface
 * @export
 * @class PackageTypesApi
 * @extends {BaseAPI}
 */
export class PackageTypesApi extends BaseAPI {
    /**
     * Create a custom package type to better assist in getting accurate rate estimates
     * @summary Create Custom Package Type
     * @param {CreatePackageTypeRequestBody} createPackageTypeRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    createPackageType(createPackageTypeRequestBody, options) {
        return PackageTypesApiFp(this.configuration).createPackageType(createPackageTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a custom package using the ID
     * @summary Delete A Custom Package By ID
     * @param {string} packageId Package ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    deletePackageType(packageId, options) {
        return PackageTypesApiFp(this.configuration).deletePackageType(packageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Custom Package Type by ID
     * @summary Get Custom Package Type By ID
     * @param {string} packageId Package ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    getPackageTypeById(packageId, options) {
        return PackageTypesApiFp(this.configuration).getPackageTypeById(packageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the custom package types associated with the account
     * @summary List Custom Package Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    listPackageTypes(options) {
        return PackageTypesApiFp(this.configuration).listPackageTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the custom package type object by ID
     * @summary Update Custom Package Type By ID
     * @param {string} packageId Package ID
     * @param {UpdatePackageTypeRequestBody} updatePackageTypeRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageTypesApi
     */
    updatePackageType(packageId, updatePackageTypeRequestBody, options) {
        return PackageTypesApiFp(this.configuration).updatePackageType(packageId, updatePackageTypeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * RatesApi - axios parameter creator
 * @export
 */
export const RatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
         * @summary Get Shipping Rates
         * @param {CalculateRatesRequestBody} calculateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRates: async (calculateRatesRequestBody, options = {}) => {
            // verify required parameter 'calculateRatesRequestBody' is not null or undefined
            assertParamExists('calculateRates', 'calculateRatesRequestBody', calculateRatesRequestBody);
            const localVarPath = `/v1/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(calculateRatesRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Bulk Shipment Rates
         * @summary Get Bulk Rates
         * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareBulkRates: async (compareBulkRatesRequestBody, options = {}) => {
            // verify required parameter 'compareBulkRatesRequestBody' is not null or undefined
            assertParamExists('compareBulkRates', 'compareBulkRatesRequestBody', compareBulkRatesRequestBody);
            const localVarPath = `/v1/rates/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(compareBulkRatesRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Rate Estimates
         * @summary Estimate Rates
         * @param {EstimateRatesRequestBody} estimateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRates: async (estimateRatesRequestBody, options = {}) => {
            // verify required parameter 'estimateRatesRequestBody' is not null or undefined
            assertParamExists('estimateRates', 'estimateRatesRequestBody', estimateRatesRequestBody);
            const localVarPath = `/v1/rates/estimate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(estimateRatesRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a previously queried rate by its ID
         * @summary Get Rate By ID
         * @param {string} rateId Rate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateById: async (rateId, options = {}) => {
            // verify required parameter 'rateId' is not null or undefined
            assertParamExists('getRateById', 'rateId', rateId);
            const localVarPath = `/v1/rates/{rate_id}`
                .replace(`{${"rate_id"}}`, encodeURIComponent(String(rateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RatesApi - functional programming interface
 * @export
 */
export const RatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = RatesApiAxiosParamCreator(configuration);
    return {
        /**
         * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
         * @summary Get Shipping Rates
         * @param {CalculateRatesRequestBody} calculateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateRates(calculateRatesRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateRates(calculateRatesRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Bulk Shipment Rates
         * @summary Get Bulk Rates
         * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compareBulkRates(compareBulkRatesRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareBulkRates(compareBulkRatesRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Rate Estimates
         * @summary Estimate Rates
         * @param {EstimateRatesRequestBody} estimateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateRates(estimateRatesRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateRates(estimateRatesRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a previously queried rate by its ID
         * @summary Get Rate By ID
         * @param {string} rateId Rate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateById(rateId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateById(rateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * RatesApi - factory interface
 * @export
 */
export const RatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RatesApiFp(configuration);
    return {
        /**
         * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
         * @summary Get Shipping Rates
         * @param {CalculateRatesRequestBody} calculateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRates(calculateRatesRequestBody, options) {
            return localVarFp.calculateRates(calculateRatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Bulk Shipment Rates
         * @summary Get Bulk Rates
         * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareBulkRates(compareBulkRatesRequestBody, options) {
            return localVarFp.compareBulkRates(compareBulkRatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Rate Estimates
         * @summary Estimate Rates
         * @param {EstimateRatesRequestBody} estimateRatesRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateRates(estimateRatesRequestBody, options) {
            return localVarFp.estimateRates(estimateRatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a previously queried rate by its ID
         * @summary Get Rate By ID
         * @param {string} rateId Rate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateById(rateId, options) {
            return localVarFp.getRateById(rateId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RatesApi - object-oriented interface
 * @export
 * @class RatesApi
 * @extends {BaseAPI}
 */
export class RatesApi extends BaseAPI {
    /**
     * It\'s not uncommon that you want to give your customer the choice between whether they want to ship the fastest, cheapest, or the most trusted route. Most companies don\'t solely ship things using a single shipping option; so we provide functionality to show you all your options!
     * @summary Get Shipping Rates
     * @param {CalculateRatesRequestBody} calculateRatesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    calculateRates(calculateRatesRequestBody, options) {
        return RatesApiFp(this.configuration).calculateRates(calculateRatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Bulk Shipment Rates
     * @summary Get Bulk Rates
     * @param {CompareBulkRatesRequestBody} compareBulkRatesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    compareBulkRates(compareBulkRatesRequestBody, options) {
        return RatesApiFp(this.configuration).compareBulkRates(compareBulkRatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Rate Estimates
     * @summary Estimate Rates
     * @param {EstimateRatesRequestBody} estimateRatesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    estimateRates(estimateRatesRequestBody, options) {
        return RatesApiFp(this.configuration).estimateRates(estimateRatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a previously queried rate by its ID
     * @summary Get Rate By ID
     * @param {string} rateId Rate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    getRateById(rateId, options) {
        return RatesApiFp(this.configuration).getRateById(rateId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ServicePointsApi - axios parameter creator
 * @export
 */
export const ServicePointsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a carrier service point by using the service_point_id
         * @summary Get Service Point By ID
         * @param {string} carrierCode Carrier code
         * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
         * @param {string} servicePointId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsGetById: async (carrierCode, countryCode, servicePointId, options = {}) => {
            // verify required parameter 'carrierCode' is not null or undefined
            assertParamExists('servicePointsGetById', 'carrierCode', carrierCode);
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('servicePointsGetById', 'countryCode', countryCode);
            // verify required parameter 'servicePointId' is not null or undefined
            assertParamExists('servicePointsGetById', 'servicePointId', servicePointId);
            const localVarPath = `/v1/service_points/{carrier_code}/{country_code}/{service_point_id}`
                .replace(`{${"carrier_code"}}`, encodeURIComponent(String(carrierCode)))
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)))
                .replace(`{${"service_point_id"}}`, encodeURIComponent(String(servicePointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List carrier service points by location
         * @summary List Service Points
         * @param {GetServicePointsRequest} getServicePointsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsList: async (getServicePointsRequest, options = {}) => {
            // verify required parameter 'getServicePointsRequest' is not null or undefined
            assertParamExists('servicePointsList', 'getServicePointsRequest', getServicePointsRequest);
            const localVarPath = `/v1/service_points/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(getServicePointsRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ServicePointsApi - functional programming interface
 * @export
 */
export const ServicePointsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ServicePointsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a carrier service point by using the service_point_id
         * @summary Get Service Point By ID
         * @param {string} carrierCode Carrier code
         * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
         * @param {string} servicePointId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicePointsGetById(carrierCode, countryCode, servicePointId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicePointsGetById(carrierCode, countryCode, servicePointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List carrier service points by location
         * @summary List Service Points
         * @param {GetServicePointsRequest} getServicePointsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicePointsList(getServicePointsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicePointsList(getServicePointsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ServicePointsApi - factory interface
 * @export
 */
export const ServicePointsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ServicePointsApiFp(configuration);
    return {
        /**
         * Returns a carrier service point by using the service_point_id
         * @summary Get Service Point By ID
         * @param {string} carrierCode Carrier code
         * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
         * @param {string} servicePointId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsGetById(carrierCode, countryCode, servicePointId, options) {
            return localVarFp.servicePointsGetById(carrierCode, countryCode, servicePointId, options).then((request) => request(axios, basePath));
        },
        /**
         * List carrier service points by location
         * @summary List Service Points
         * @param {GetServicePointsRequest} getServicePointsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePointsList(getServicePointsRequest, options) {
            return localVarFp.servicePointsList(getServicePointsRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ServicePointsApi - object-oriented interface
 * @export
 * @class ServicePointsApi
 * @extends {BaseAPI}
 */
export class ServicePointsApi extends BaseAPI {
    /**
     * Returns a carrier service point by using the service_point_id
     * @summary Get Service Point By ID
     * @param {string} carrierCode Carrier code
     * @param {string} countryCode A two-letter [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1)
     * @param {string} servicePointId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointsApi
     */
    servicePointsGetById(carrierCode, countryCode, servicePointId, options) {
        return ServicePointsApiFp(this.configuration).servicePointsGetById(carrierCode, countryCode, servicePointId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List carrier service points by location
     * @summary List Service Points
     * @param {GetServicePointsRequest} getServicePointsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointsApi
     */
    servicePointsList(getServicePointsRequest, options) {
        return ServicePointsApiFp(this.configuration).servicePointsList(getServicePointsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
export const ShipmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
         * @summary Cancel a Shipment
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipments: async (shipmentId, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('cancelShipments', 'shipmentId', shipmentId);
            const localVarPath = `/v1/shipments/{shipment_id}/cancel`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create one or multiple shipments.
         * @summary Create Shipments
         * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments: async (createShipmentsRequestBody, options = {}) => {
            // verify required parameter 'createShipmentsRequestBody' is not null or undefined
            assertParamExists('createShipments', 'createShipmentsRequestBody', createShipmentsRequestBody);
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createShipmentsRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query Shipments created using your own custom ID convention using this endpint
         * @summary Get Shipment By External ID
         * @param {string} externalShipmentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentByExternalId: async (externalShipmentId, options = {}) => {
            // verify required parameter 'externalShipmentId' is not null or undefined
            assertParamExists('getShipmentByExternalId', 'externalShipmentId', externalShipmentId);
            const localVarPath = `/v1/shipments/external_shipment_id/{external_shipment_id}`
                .replace(`{${"external_shipment_id"}}`, encodeURIComponent(String(externalShipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual shipment based on its ID
         * @summary Get Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentById: async (shipmentId, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('getShipmentById', 'shipmentId', shipmentId);
            const localVarPath = `/v1/shipments/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Rates for the shipment information associated with the shipment ID
         * @summary Get Shipment Rates
         * @param {string} shipmentId Shipment ID
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipmentRates: async (shipmentId, createdAtStart, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('listShipmentRates', 'shipmentId', shipmentId);
            const localVarPath = `/v1/shipments/{shipment_id}/rates`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of Shipments
         * @summary List Shipments
         * @param {ShipmentStatus} [shipmentStatus]
         * @param {string} [batchId] Batch ID
         * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
         * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {string} [salesOrderId] Sales Order ID
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ShipmentsSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipments: async (shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options = {}) => {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (shipmentStatus !== undefined) {
                localVarQueryParameter['shipment_status'] = shipmentStatus;
            }
            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }
            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }
            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart instanceof Date) ?
                    createdAtStart.toISOString() :
                    createdAtStart;
            }
            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd instanceof Date) ?
                    createdAtEnd.toISOString() :
                    createdAtEnd;
            }
            if (modifiedAtStart !== undefined) {
                localVarQueryParameter['modified_at_start'] = (modifiedAtStart instanceof Date) ?
                    modifiedAtStart.toISOString() :
                    modifiedAtStart;
            }
            if (modifiedAtEnd !== undefined) {
                localVarQueryParameter['modified_at_end'] = (modifiedAtEnd instanceof Date) ?
                    modifiedAtEnd.toISOString() :
                    modifiedAtEnd;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (salesOrderId !== undefined) {
                localVarQueryParameter['sales_order_id'] = salesOrderId;
            }
            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse shipping info
         * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseShipment: async (parseShipmentRequestBody, options = {}) => {
            // verify required parameter 'parseShipmentRequestBody' is not null or undefined
            assertParamExists('parseShipment', 'parseShipmentRequestBody', parseShipmentRequestBody);
            const localVarPath = `/v1/shipments/recognize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(parseShipmentRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to the shipment object
         * @summary Add Tag to Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShipment: async (shipmentId, tagName, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('tagShipment', 'shipmentId', shipmentId);
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('tagShipment', 'tagName', tagName);
            const localVarPath = `/v1/shipments/{shipment_id}/tags/{tag_name}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an existing tag from the Shipment object
         * @summary Remove Tag from Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagShipment: async (shipmentId, tagName, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('untagShipment', 'shipmentId', shipmentId);
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('untagShipment', 'tagName', tagName);
            const localVarPath = `/v1/shipments/{shipment_id}/tags/{tag_name}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a shipment object based on its ID
         * @summary Update Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipment: async (shipmentId, updateShipmentRequestBody, options = {}) => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('updateShipment', 'shipmentId', shipmentId);
            // verify required parameter 'updateShipmentRequestBody' is not null or undefined
            assertParamExists('updateShipment', 'updateShipmentRequestBody', updateShipmentRequestBody);
            const localVarPath = `/v1/shipments/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateShipmentRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ShipmentsApi - functional programming interface
 * @export
 */
export const ShipmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ShipmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
         * @summary Cancel a Shipment
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelShipments(shipmentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelShipments(shipmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create one or multiple shipments.
         * @summary Create Shipments
         * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipments(createShipmentsRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipments(createShipmentsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query Shipments created using your own custom ID convention using this endpint
         * @summary Get Shipment By External ID
         * @param {string} externalShipmentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShipmentByExternalId(externalShipmentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShipmentByExternalId(externalShipmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an individual shipment based on its ID
         * @summary Get Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShipmentById(shipmentId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShipmentById(shipmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Rates for the shipment information associated with the shipment ID
         * @summary Get Shipment Rates
         * @param {string} shipmentId Shipment ID
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShipmentRates(shipmentId, createdAtStart, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShipmentRates(shipmentId, createdAtStart, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of Shipments
         * @summary List Shipments
         * @param {ShipmentStatus} [shipmentStatus]
         * @param {string} [batchId] Batch ID
         * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
         * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {string} [salesOrderId] Sales Order ID
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ShipmentsSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse shipping info
         * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseShipment(parseShipmentRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseShipment(parseShipmentRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to the shipment object
         * @summary Add Tag to Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagShipment(shipmentId, tagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagShipment(shipmentId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an existing tag from the Shipment object
         * @summary Remove Tag from Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untagShipment(shipmentId, tagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untagShipment(shipmentId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a shipment object based on its ID
         * @summary Update Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShipment(shipmentId, updateShipmentRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShipment(shipmentId, updateShipmentRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ShipmentsApi - factory interface
 * @export
 */
export const ShipmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ShipmentsApiFp(configuration);
    return {
        /**
         * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
         * @summary Cancel a Shipment
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShipments(shipmentId, options) {
            return localVarFp.cancelShipments(shipmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create one or multiple shipments.
         * @summary Create Shipments
         * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments(createShipmentsRequestBody, options) {
            return localVarFp.createShipments(createShipmentsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query Shipments created using your own custom ID convention using this endpint
         * @summary Get Shipment By External ID
         * @param {string} externalShipmentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentByExternalId(externalShipmentId, options) {
            return localVarFp.getShipmentByExternalId(externalShipmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual shipment based on its ID
         * @summary Get Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipmentById(shipmentId, options) {
            return localVarFp.getShipmentById(shipmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Rates for the shipment information associated with the shipment ID
         * @summary Get Shipment Rates
         * @param {string} shipmentId Shipment ID
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipmentRates(shipmentId, createdAtStart, options) {
            return localVarFp.listShipmentRates(shipmentId, createdAtStart, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of Shipments
         * @summary List Shipments
         * @param {ShipmentStatus} [shipmentStatus]
         * @param {string} [batchId] Batch ID
         * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
         * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
         * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
         * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
         * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
         * @param {number} [pageSize] The number of results to return per response.
         * @param {string} [salesOrderId] Sales Order ID
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {ShipmentsSortBy} [sortBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options) {
            return localVarFp.listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
         * @summary Parse shipping info
         * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseShipment(parseShipmentRequestBody, options) {
            return localVarFp.parseShipment(parseShipmentRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to the shipment object
         * @summary Add Tag to Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagShipment(shipmentId, tagName, options) {
            return localVarFp.tagShipment(shipmentId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an existing tag from the Shipment object
         * @summary Remove Tag from Shipment
         * @param {string} shipmentId Shipment ID
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagShipment(shipmentId, tagName, options) {
            return localVarFp.untagShipment(shipmentId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a shipment object based on its ID
         * @summary Update Shipment By ID
         * @param {string} shipmentId Shipment ID
         * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShipment(shipmentId, updateShipmentRequestBody, options) {
            return localVarFp.updateShipment(shipmentId, updateShipmentRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Mark a shipment cancelled, if it is no longer needed or being used by your organized. Any label associated with the shipment needs to be voided first An example use case would be if a batch label creation job is going to run at a set time and only queries `pending` shipments. Marking a shipment as cancelled would remove it from this process
     * @summary Cancel a Shipment
     * @param {string} shipmentId Shipment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    cancelShipments(shipmentId, options) {
        return ShipmentsApiFp(this.configuration).cancelShipments(shipmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create one or multiple shipments.
     * @summary Create Shipments
     * @param {CreateShipmentsRequestBody} createShipmentsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    createShipments(createShipmentsRequestBody, options) {
        return ShipmentsApiFp(this.configuration).createShipments(createShipmentsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query Shipments created using your own custom ID convention using this endpint
     * @summary Get Shipment By External ID
     * @param {string} externalShipmentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    getShipmentByExternalId(externalShipmentId, options) {
        return ShipmentsApiFp(this.configuration).getShipmentByExternalId(externalShipmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an individual shipment based on its ID
     * @summary Get Shipment By ID
     * @param {string} shipmentId Shipment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    getShipmentById(shipmentId, options) {
        return ShipmentsApiFp(this.configuration).getShipmentById(shipmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Rates for the shipment information associated with the shipment ID
     * @summary Get Shipment Rates
     * @param {string} shipmentId Shipment ID
     * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    listShipmentRates(shipmentId, createdAtStart, options) {
        return ShipmentsApiFp(this.configuration).listShipmentRates(shipmentId, createdAtStart, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get list of Shipments
     * @summary List Shipments
     * @param {ShipmentStatus} [shipmentStatus]
     * @param {string} [batchId] Batch ID
     * @param {string} [tag] Search for shipments based on the custom tag added to the shipment object
     * @param {string} [createdAtStart] Used to create a filter for when a resource was created (ex. A shipment that was created after a certain time)
     * @param {string} [createdAtEnd] Used to create a filter for when a resource was created, (ex. A shipment that was created before a certain time)
     * @param {string} [modifiedAtStart] Used to create a filter for when a resource was modified (ex. A shipment that was modified after a certain time)
     * @param {string} [modifiedAtEnd] Used to create a filter for when a resource was modified (ex. A shipment that was modified before a certain time)
     * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned.
     * @param {number} [pageSize] The number of results to return per response.
     * @param {string} [salesOrderId] Sales Order ID
     * @param {SortDir} [sortDir] Controls the sort order of the query.
     * @param {ShipmentsSortBy} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options) {
        return ShipmentsApiFp(this.configuration).listShipments(shipmentStatus, batchId, tag, createdAtStart, createdAtEnd, modifiedAtStart, modifiedAtEnd, page, pageSize, salesOrderId, sortDir, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The shipment-recognition API makes it easy for you to extract shipping data from unstructured text, including people\'s names, addresses, package weights and dimensions, insurance and delivery requirements, and more.  Data often enters your system as unstructured text (for example: emails, SMS messages, support tickets, or other documents). ShipEngine\'s shipment-recognition API helps you extract meaningful, structured data from this unstructured text. The parsed shipment data is returned in the same structure that\'s used for other ShipEngine APIs, so you can easily use the parsed data to create a shipping label.  > **Note:** Shipment recognition is currently supported for the United States, Canada, Australia, New Zealand, the United Kingdom, and Ireland.
     * @summary Parse shipping info
     * @param {ParseShipmentRequestBody} parseShipmentRequestBody The only required field is &#x60;text&#x60;, which is the text to be parsed. You can optionally also provide a &#x60;shipment&#x60; containing any already-known values. For example, you probably already know the &#x60;ship_from&#x60; address, and you may also already know what carrier and service you want to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    parseShipment(parseShipmentRequestBody, options) {
        return ShipmentsApiFp(this.configuration).parseShipment(parseShipmentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a tag to the shipment object
     * @summary Add Tag to Shipment
     * @param {string} shipmentId Shipment ID
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    tagShipment(shipmentId, tagName, options) {
        return ShipmentsApiFp(this.configuration).tagShipment(shipmentId, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove an existing tag from the Shipment object
     * @summary Remove Tag from Shipment
     * @param {string} shipmentId Shipment ID
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    untagShipment(shipmentId, tagName, options) {
        return ShipmentsApiFp(this.configuration).untagShipment(shipmentId, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a shipment object based on its ID
     * @summary Update Shipment By ID
     * @param {string} shipmentId Shipment ID
     * @param {UpdateShipmentRequestBody} updateShipmentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    updateShipment(shipmentId, updateShipmentRequestBody, options) {
        return ShipmentsApiFp(this.configuration).updateShipment(shipmentId, updateShipmentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new Tag for customizing how you track your shipments
         * @summary Create a New Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (tagName, options = {}) => {
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('createTag', 'tagName', tagName);
            const localVarPath = `/v1/tags/{tag_name}`
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag that is no longer needed
         * @summary Delete Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagName, options = {}) => {
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteTag', 'tagName', tagName);
            const localVarPath = `/v1/tags/{tag_name}`
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all tags associated with an account.
         * @summary Get Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (options = {}) => {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change a tag name while still keeping the relevant shipments attached to it
         * @summary Update Tag Name
         * @param {string} tagName
         * @param {string} newTagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag: async (tagName, newTagName, options = {}) => {
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('renameTag', 'tagName', tagName);
            // verify required parameter 'newTagName' is not null or undefined
            assertParamExists('renameTag', 'newTagName', newTagName);
            const localVarPath = `/v1/tags/{tag_name}/{new_tag_name}`
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)))
                .replace(`{${"new_tag_name"}}`, encodeURIComponent(String(newTagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new Tag for customizing how you track your shipments
         * @summary Create a New Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(tagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag that is no longer needed
         * @summary Delete Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all tags associated with an account.
         * @summary Get Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change a tag name while still keeping the relevant shipments attached to it
         * @summary Update Tag Name
         * @param {string} tagName
         * @param {string} newTagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameTag(tagName, newTagName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameTag(tagName, newTagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TagsApiFp(configuration);
    return {
        /**
         * Create a new Tag for customizing how you track your shipments
         * @summary Create a New Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(tagName, options) {
            return localVarFp.createTag(tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag that is no longer needed
         * @summary Delete Tag
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagName, options) {
            return localVarFp.deleteTag(tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all tags associated with an account.
         * @summary Get Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options) {
            return localVarFp.listTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Change a tag name while still keeping the relevant shipments attached to it
         * @summary Update Tag Name
         * @param {string} tagName
         * @param {string} newTagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tagName, newTagName, options) {
            return localVarFp.renameTag(tagName, newTagName, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Create a new Tag for customizing how you track your shipments
     * @summary Create a New Tag
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    createTag(tagName, options) {
        return TagsApiFp(this.configuration).createTag(tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a tag that is no longer needed
     * @summary Delete Tag
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    deleteTag(tagName, options) {
        return TagsApiFp(this.configuration).deleteTag(tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of all tags associated with an account.
     * @summary Get Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    listTags(options) {
        return TagsApiFp(this.configuration).listTags(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Change a tag name while still keeping the relevant shipments attached to it
     * @summary Update Tag Name
     * @param {string} tagName
     * @param {string} newTagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    renameTag(tagName, newTagName, options) {
        return TagsApiFp(this.configuration).renameTag(tagName, newTagName, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
         * @summary Get Ephemeral Token
         * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGetEphemeralToken: async (redirect, options = {}) => {
            const localVarPath = `/v1/tokens/ephemeral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
    return {
        /**
         * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
         * @summary Get Ephemeral Token
         * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGetEphemeralToken(redirect, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGetEphemeralToken(redirect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TokensApiFp(configuration);
    return {
        /**
         * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
         * @summary Get Ephemeral Token
         * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGetEphemeralToken(redirect, options) {
            return localVarFp.tokensGetEphemeralToken(redirect, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * This endpoint returns a token that can be passed to an application for authorized access.  The lifetime of this token is 10 seconds.
     * @summary Get Ephemeral Token
     * @param {Redirect} [redirect] Include a redirect url to the application formatted with the ephemeral token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensGetEphemeralToken(redirect, options) {
        return TokensApiFp(this.configuration).tokensGetEphemeralToken(redirect, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TrackingApi - axios parameter creator
 * @export
 */
export const TrackingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve package tracking information
         * @summary Get Tracking Information
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLog: async (carrierCode, trackingNumber, options = {}) => {
            const localVarPath = `/v1/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
         * @summary Start Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTracking: async (carrierCode, trackingNumber, options = {}) => {
            const localVarPath = `/v1/tracking/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe from tracking updates for a package.
         * @summary Stop Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTracking: async (carrierCode, trackingNumber, options = {}) => {
            const localVarPath = `/v1/tracking/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            if (carrierCode !== undefined) {
                localVarQueryParameter['carrier_code'] = carrierCode;
            }
            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TrackingApi - functional programming interface
 * @export
 */
export const TrackingApiFp = function (configuration) {
    const localVarAxiosParamCreator = TrackingApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve package tracking information
         * @summary Get Tracking Information
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackingLog(carrierCode, trackingNumber, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackingLog(carrierCode, trackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
         * @summary Start Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTracking(carrierCode, trackingNumber, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTracking(carrierCode, trackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribe from tracking updates for a package.
         * @summary Stop Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTracking(carrierCode, trackingNumber, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTracking(carrierCode, trackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TrackingApi - factory interface
 * @export
 */
export const TrackingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TrackingApiFp(configuration);
    return {
        /**
         * Retrieve package tracking information
         * @summary Get Tracking Information
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingLog(carrierCode, trackingNumber, options) {
            return localVarFp.getTrackingLog(carrierCode, trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
         * @summary Start Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTracking(carrierCode, trackingNumber, options) {
            return localVarFp.startTracking(carrierCode, trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe from tracking updates for a package.
         * @summary Stop Tracking a Package
         * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
         * @param {string} [trackingNumber] The tracking number associated with a shipment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTracking(carrierCode, trackingNumber, options) {
            return localVarFp.stopTracking(carrierCode, trackingNumber, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TrackingApi - object-oriented interface
 * @export
 * @class TrackingApi
 * @extends {BaseAPI}
 */
export class TrackingApi extends BaseAPI {
    /**
     * Retrieve package tracking information
     * @summary Get Tracking Information
     * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
     * @param {string} [trackingNumber] The tracking number associated with a shipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    getTrackingLog(carrierCode, trackingNumber, options) {
        return TrackingApiFp(this.configuration).getTrackingLog(carrierCode, trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to subscribe to tracking updates for a package. You specify the carrier_code and tracking_number of the package, and receive notifications via webhooks whenever the shipping status changes.
     * @summary Start Tracking a Package
     * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
     * @param {string} [trackingNumber] The tracking number associated with a shipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    startTracking(carrierCode, trackingNumber, options) {
        return TrackingApiFp(this.configuration).startTracking(carrierCode, trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unsubscribe from tracking updates for a package.
     * @summary Stop Tracking a Package
     * @param {string} [carrierCode] A [shipping carrier](https://www.shipengine.com/docs/carriers/setup/), such as &#x60;fedex&#x60;, &#x60;dhl_express&#x60;, &#x60;stamps_com&#x60;, etc.
     * @param {string} [trackingNumber] The tracking number associated with a shipment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    stopTracking(carrierCode, trackingNumber, options) {
        return TrackingApiFp(this.configuration).stopTracking(carrierCode, trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WarehousesApi - axios parameter creator
 * @export
 */
export const WarehousesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
         * @summary Create Warehouse
         * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse: async (createWarehouseRequestBody, options = {}) => {
            // verify required parameter 'createWarehouseRequestBody' is not null or undefined
            assertParamExists('createWarehouse', 'createWarehouseRequestBody', createWarehouseRequestBody);
            const localVarPath = `/v1/warehouses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createWarehouseRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a warehouse by ID
         * @summary Delete Warehouse By ID
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse: async (warehouseId, options = {}) => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('deleteWarehouse', 'warehouseId', warehouseId);
            const localVarPath = `/v1/warehouses/{warehouse_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve warehouse data based on the warehouse ID
         * @summary Get Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseById: async (warehouseId, options = {}) => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('getWarehouseById', 'warehouseId', warehouseId);
            const localVarPath = `/v1/warehouses/{warehouse_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of warehouses associated with this account.
         * @summary List Warehouses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarehouses: async (options = {}) => {
            const localVarPath = `/v1/warehouses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Warehouse object information
         * @summary Update Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouse: async (warehouseId, updateWarehouseRequestBody, options = {}) => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('updateWarehouse', 'warehouseId', warehouseId);
            // verify required parameter 'updateWarehouseRequestBody' is not null or undefined
            assertParamExists('updateWarehouse', 'updateWarehouseRequestBody', updateWarehouseRequestBody);
            const localVarPath = `/v1/warehouses/{warehouse_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateWarehouseRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Warehouse settings object information
         * @summary Update Warehouse Settings
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouseSettings: async (warehouseId, updateWarehouseSettingsRequestBody, options = {}) => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('updateWarehouseSettings', 'warehouseId', warehouseId);
            // verify required parameter 'updateWarehouseSettingsRequestBody' is not null or undefined
            assertParamExists('updateWarehouseSettings', 'updateWarehouseSettingsRequestBody', updateWarehouseSettingsRequestBody);
            const localVarPath = `/v1/warehouses/{warehouse_id}/settings`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateWarehouseSettingsRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WarehousesApi - functional programming interface
 * @export
 */
export const WarehousesApiFp = function (configuration) {
    const localVarAxiosParamCreator = WarehousesApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
         * @summary Create Warehouse
         * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWarehouse(createWarehouseRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWarehouse(createWarehouseRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a warehouse by ID
         * @summary Delete Warehouse By ID
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWarehouse(warehouseId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWarehouse(warehouseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve warehouse data based on the warehouse ID
         * @summary Get Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarehouseById(warehouseId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarehouseById(warehouseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of warehouses associated with this account.
         * @summary List Warehouses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWarehouses(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWarehouses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Warehouse object information
         * @summary Update Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWarehouse(warehouseId, updateWarehouseRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWarehouse(warehouseId, updateWarehouseRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Warehouse settings object information
         * @summary Update Warehouse Settings
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * WarehousesApi - factory interface
 * @export
 */
export const WarehousesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WarehousesApiFp(configuration);
    return {
        /**
         * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
         * @summary Create Warehouse
         * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse(createWarehouseRequestBody, options) {
            return localVarFp.createWarehouse(createWarehouseRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a warehouse by ID
         * @summary Delete Warehouse By ID
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse(warehouseId, options) {
            return localVarFp.deleteWarehouse(warehouseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve warehouse data based on the warehouse ID
         * @summary Get Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseById(warehouseId, options) {
            return localVarFp.getWarehouseById(warehouseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of warehouses associated with this account.
         * @summary List Warehouses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarehouses(options) {
            return localVarFp.listWarehouses(options).then((request) => request(axios, basePath));
        },
        /**
         * Update Warehouse object information
         * @summary Update Warehouse By Id
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouse(warehouseId, updateWarehouseRequestBody, options) {
            return localVarFp.updateWarehouse(warehouseId, updateWarehouseRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Warehouse settings object information
         * @summary Update Warehouse Settings
         * @param {string} warehouseId Warehouse ID
         * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options) {
            return localVarFp.updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WarehousesApi - object-oriented interface
 * @export
 * @class WarehousesApi
 * @extends {BaseAPI}
 */
export class WarehousesApi extends BaseAPI {
    /**
     * Create a warehouse location that you can use to create shipping items by simply passing in the generated warehouse id. If the return address is not supplied in the request body then it is assumed that the origin address is the return address as well
     * @summary Create Warehouse
     * @param {CreateWarehouseRequestBody} createWarehouseRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    createWarehouse(createWarehouseRequestBody, options) {
        return WarehousesApiFp(this.configuration).createWarehouse(createWarehouseRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a warehouse by ID
     * @summary Delete Warehouse By ID
     * @param {string} warehouseId Warehouse ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    deleteWarehouse(warehouseId, options) {
        return WarehousesApiFp(this.configuration).deleteWarehouse(warehouseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve warehouse data based on the warehouse ID
     * @summary Get Warehouse By Id
     * @param {string} warehouseId Warehouse ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    getWarehouseById(warehouseId, options) {
        return WarehousesApiFp(this.configuration).getWarehouseById(warehouseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of warehouses associated with this account.
     * @summary List Warehouses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    listWarehouses(options) {
        return WarehousesApiFp(this.configuration).listWarehouses(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Warehouse object information
     * @summary Update Warehouse By Id
     * @param {string} warehouseId Warehouse ID
     * @param {UpdateWarehouseRequestBody} updateWarehouseRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    updateWarehouse(warehouseId, updateWarehouseRequestBody, options) {
        return WarehousesApiFp(this.configuration).updateWarehouse(warehouseId, updateWarehouseRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Warehouse settings object information
     * @summary Update Warehouse Settings
     * @param {string} warehouseId Warehouse ID
     * @param {UpdateWarehouseSettingsRequestBody} updateWarehouseSettingsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehousesApi
     */
    updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options) {
        return WarehousesApiFp(this.configuration).updateWarehouseSettings(warehouseId, updateWarehouseSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a webook for specific events in the environment.
         * @summary Create a Webhook
         * @param {CreateWebhookRequestBody} createWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequestBody, options = {}) => {
            // verify required parameter 'createWebhookRequestBody' is not null or undefined
            assertParamExists('createWebhook', 'createWebhookRequestBody', createWebhookRequestBody);
            const localVarPath = `/v1/environment/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook
         * @summary Delete Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId, options = {}) => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId);
            const localVarPath = `/v1/environment/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve individual webhook by an ID
         * @summary Get Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookById: async (webhookId, options = {}) => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhookById', 'webhookId', webhookId);
            const localVarPath = `/v1/environment/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all webhooks currently enabled for the account.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (options = {}) => {
            const localVarPath = `/v1/environment/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the webhook url property
         * @summary Update a Webhook
         * @param {string} webhookId Webhook ID
         * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId, updateWebhookRequestBody, options = {}) => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId);
            // verify required parameter 'updateWebhookRequestBody' is not null or undefined
            assertParamExists('updateWebhook', 'updateWebhookRequestBody', updateWebhookRequestBody);
            const localVarPath = `/v1/environment/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a webook for specific events in the environment.
         * @summary Create a Webhook
         * @param {CreateWebhookRequestBody} createWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook
         * @summary Delete Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve individual webhook by an ID
         * @summary Get Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookById(webhookId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookById(webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all webhooks currently enabled for the account.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the webhook url property
         * @summary Update a Webhook
         * @param {string} webhookId Webhook ID
         * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId, updateWebhookRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WebhooksApiFp(configuration);
    return {
        /**
         * Create a webook for specific events in the environment.
         * @summary Create a Webhook
         * @param {CreateWebhookRequestBody} createWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequestBody, options) {
            return localVarFp.createWebhook(createWebhookRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook
         * @summary Delete Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve individual webhook by an ID
         * @summary Get Webhook By ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookById(webhookId, options) {
            return localVarFp.getWebhookById(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all webhooks currently enabled for the account.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the webhook url property
         * @summary Update a Webhook
         * @param {string} webhookId Webhook ID
         * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, updateWebhookRequestBody, options) {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a webook for specific events in the environment.
     * @summary Create a Webhook
     * @param {CreateWebhookRequestBody} createWebhookRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookRequestBody, options) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a webhook
     * @summary Delete Webhook By ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(webhookId, options) {
        return WebhooksApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve individual webhook by an ID
     * @summary Get Webhook By ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhookById(webhookId, options) {
        return WebhooksApiFp(this.configuration).getWebhookById(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all webhooks currently enabled for the account.
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhooks(options) {
        return WebhooksApiFp(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the webhook url property
     * @summary Update a Webhook
     * @param {string} webhookId Webhook ID
     * @param {UpdateWebhookRequestBody} updateWebhookRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(webhookId, updateWebhookRequestBody, options) {
        return WebhooksApiFp(this.configuration).updateWebhook(webhookId, updateWebhookRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
